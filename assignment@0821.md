




任务：撰写两个 API 接口:

- 短域名存储接口：接受长域名信息，返回短域名信息
- 短域名读取接口：接受短域名信息，返回长域名信息。
 
Jacoco单元测试覆盖率截图(行覆盖率和分支覆盖率85%+)
![image](https://user-images.githubusercontent.com/36940753/130890459-f587d83b-974e-42b5-9bc4-ea5f6869eb61.png)



设计思路

	通过发号策略，解析每一个传入的长地址，对该地址进行拆分，域名地址发一个号，域名地址后面的部分，发另外一个号。这两个号可以用一样的策略，各用一个62进制的4位数自增来实现即可满足小型系统的需要。这种方式实现的优点是同一长地址，只有一个短地址，无论转换后的域名地址还是域名地址后面的剩余部分。
	4位62进制的容量为62*62*62*62=14,776,336，该发号程序可以通过修改配置文件实现短域名地址改为5位或者6位64进制的自增号，5位62进制的容量为916,132,832；容量足够中型系统的需要使用。
    通过两对ConcurrentHashMap来实现长短域名存储和查询。
    

长短域名实现架构示意图
     在大并发量的查询情形下，可以参考下图分层构建，client端，硬件负载均衡，软负载均衡，网关，长短域名应用服务，缓存存储层，日志监控管理分析等。
   在nginx和网关这一层，可以实现安全，权限，路由转发，限流，降级等功能。  
![1629945190](https://user-images.githubusercontent.com/36940753/130890833-83668287-6387-4bb4-8a11-ad67bc35a36b.png)


选型ConcurrentHashMap分析 
（1）数组与链表的珠联璧合：结合了数组的查找效率为O(1) 与链表的插入和删除效率为O(1)的特性，互相取长补短，达到高效；
（2）红黑树：为了解决冲突元素过多>8 单链表的0(N)查询问题，引入了红黑树提高查询效率到O(logN)；尤其在本设计中，通过发号器来生成KEY,该key和对应的value存储到ConcurrentHashMap 中，不会存在冲突元素过多>8的问题。经过验证测试，将1024000个具备唯一性的KEY值和对应的value存储到一个空的ConcurrentHashMap中，测试结果如下：
![1629945224(1)](https://user-images.githubusercontent.com/36940753/130890883-df07b175-4228-4a05-b539-a51d429fb5ab.png)


将1百万条URL记录插入ConcurrentHashMap,该MAP的记录数和要插入的记录数是一致的，此情形下，记录的查询效率为O(1).
（3）空间换时间：经常当应用缓存使用，其实是避免硬盘io，使用内存空间换时间得到了O(1)的时间查询；
（4）粒度锁：使用数组Table[]分段锁来减小锁的粒度，提高程序的并发度；

发号器设计
发号器的设计目标
1、分布式环境下，保证每个序列号（sequence）是唯一的；
2、序列号可排序，满足单调递增的规律；
3、特定场景下，能生成无规则（或者看不出规则）的序列号；
4、生成的序列号尽量短；
设计思路
1、26个小写字母+26个大写字母+10个数字合计62个字符可用；
2、62进制的5位字符串，容量达到9亿1千6百万的序列号空间，足够一定规模的系统使用；
3、将可以自定义的序列号存储在内存中，通过内存自增运算，返回自增后的序列号给应用程序使用；
4、因为序列号可以自定义，可以分段（segment）进行管理，如62个字母开头的序列，部署到不同的服务器中，或者说不通的发号程序，对应不同段的序列号段。这样保证了序列号的唯一性。

在本任务中，如果考虑域名部分地址是固定为类似"t.cn“即
url0=https://blog.csdn.net/justloveyou_/article/details/72783008
和url1=https://www.sina.com.cn/justloveyou_/article/details/72783008
分别对应成如https://t.cn/aabde 和https://t.cn/aaabdf 这样的短地址，可以通过非常简单的修改程序来实现。这种情况下，只需要存储到一对ConcurrentHashMap中即可；发号器只需要用一个。



短域名存储接口实现流程

![1629945276(1)](https://user-images.githubusercontent.com/36940753/130890956-cbf6a50e-358a-4067-9533-fc6a64d445a5.png)

短域名读取接口实现流程

![1629945307(1)](https://user-images.githubusercontent.com/36940753/130890995-e8266669-e2b4-4ed9-b931-0df99b021069.png)


性能测试情况
1 Jmeter测试情况

![1629945341(1)](https://user-images.githubusercontent.com/36940753/130891038-3e72e929-d611-493b-9882-5700fe57799a.png)

测试环境,为个人工作用笔记本电脑
(1)操作系统：64位，WIN 10家庭版
(2)CPU： Intel(R) Celeron(R) CPU J3455 @ 1.50GHz   1.50 GHz
(3)内存：12G 

从文件中读取10万个不同的长域名，长域名转换短域名接口服务为单线程，jmeter client端并发20线程进行请求，服务响应平均时间是9豪秒，最小时间是1毫米，最大时间是491毫秒，吞吐量为2005笔/秒。

2  JVM监视情况

![1629945379(1)](https://user-images.githubusercontent.com/36940753/130891087-de1369a7-2d98-4a32-8c0e-23a364cf8e91.png)





