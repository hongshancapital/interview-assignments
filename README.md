短域名服务
-----

### 作业：
Typescript 实现短域名服务（细节可以百度/谷歌）

**撰写两个 API 接口：**
- 短域名存储接口：接受长域名信息，返回短域名信息
- 短域名读取接口：接受短域名信息，返回长域名信息。

**限制：**
- 短域名长度最大为 8 个字符（不含域名）

**递交作业内容：**
- 源代码
- 单元测试代码以及单元测试覆盖率
- API 集成测试案例以及测试结果
- 简单的框架设计图，以及所有做的假设
- 涉及的 SQL 或者 NoSQL 的 Schema，注意标注出 Primary key 和 Index 如果有。

**其他：**
我们期望不要过度设计，每一个依赖以及每一行代码都有足够充分的理由。


### 概要
短域名服务，就是处理我们平常经常收到的那种带有短链的短信中的短链的，如长域名 https://www.mydomain.com/user/info?a=1&b=2&c=3 转成短域名 https://www.d.cn/ab7Hu， 其中 ab7Hu 是短域名标识（flag）。

本系统提供两个基本 API 供外部使用：
- 短域名存储接口：接受长域名信息，返回短域名信息；
- 短域名读取接口：接受短域名信息，返回长域名信息；

### 设计关键点
短域名服务的数据量和查询量很大，作为生产可用的系统，需着重考虑这两方面的性能优化： 
1. **高效的 flag 生成和解析策略**。短域名标识（flag）需要具备简单、高效、唯一的特点，以在空间和时间资源上都有很好的表现；
1. **分表**。该系统的预估数据量是亿级别的，所以前期即要考虑好分表策略，同时该分表策略要求双向查询的友好性（即不但要支持短域名到长域名的查询，也要支持长域名到短域名的查询）；
1. **查询缓存**。查询主要集中于“短域名->长域名”的查询，由于这种映射关系非常稳定，很适合做缓存，所以系统采用 Redis 作为前置缓存系统，承载绝大部分的查询；
1. **安全**。对外接口应考虑鉴权、限流，防止非法的暴力攻击。另外需要有较好的策略应对缓存穿透，以应对当面对暴力攻击时能很好地保护数据库；

### 域名标识的生成
短域名到长域名映射的本质是域名标识的映射，即 ab7Hu 映射到指定的长域名 url。

我们的想法是根据进制转换，用 10 进制值的 62 进制表示（0-9、a-z、A-Z 共 62 个）来表达这个 flag，这样我们在数据库实际上是处理整数，能够提高处理效率（这个十进制可以直接由数据库主键自增 id 得到，对插入和查询都有不错的性能，而且足够简单）。

> 即生成时是 10 进制转 62 进制，解析时是 62 进制转 10 进制。

flag 最长 8 位，我们用其中高 7 位表示整数值，低 1 位作为标志位（保存校验和、版本号等为其提高可扩展性）。最大 7 位是 zzzzzzz，对应 10 进制是 3521614606207，可生成 3.5 万亿个短链接。

之所以保存校验和是为了能够快速验证 flag 的合法性，应对攻击者生成大量随机 flag 执行攻击。保存版本号是为了防止未来需要调整 flag 生成算法，根据版本号就能知道应该使用哪种算法解析 flag。

> 具体实现见程序，比如我们可以将一个字节中的 4 bit 作为版本号，另外 4 bit 作为校验和。

### 分表
因为预期数据量比较大（最多能生成万亿级别个短连接，实际生产应该也是亿级别），所以前期就必须考虑好分表策略。

> 注：本次提交的代码未实现分表逻辑。

该系统需要支持两种查询：
1. 根据短链（flag）查长链：根据 flag 能够快速知道去哪张表查对应的 url 信息（查询时用到）；
2. 根据长链查短链（flag）：根据长链接 url 能够快速知道去哪张表查该 url 有没有生成过，以及对应的 flag 是什么（创建时用到）；
   
**本系统的分表策略**：根据长链接的 crc32 值决定插入到哪张表。另外每张表严格界定其 id 的起止范围，这样我们拿到 flag（转成 10 进制后）就能知道去哪张表查，进而解决了双向查询问题。

比如用 url 的 crc32 值对表数量取模决定插入到哪张表；每张表固定其 id 范围为一亿（第一张表 id 范围为一到一亿，第二张为一亿零一到两亿），当拿到具体 id 后就很容易判断该去哪张表查询。

因为每张表是固定 id 的，所以分表扩容（如原本 100 张表扩容到 200 张表）时不能迁移任何数据（即诸如一致性哈希策略并不适用）。

可以采用批次号的策略。我们可以以 100 张表作为一个批次，由配置文件（或配置系统）记录当前分表批次号（从 0 开始累加），crc32 值对 100 取模后还要乘以批次号得到最终的分表编号。

> 批次号策略的问题是根据 url（crc32 值）查记录时稍微麻烦，需要分别到各批次中的某张表中查询（如共一千张表，十个批次，则最多要查十张表），不过由于这种查询只有在创建短链接时才会执行，再加上布隆过滤器的前置过滤，实际并无多大影响（另外可以通过加大批次表数量来减少查询次数）。
> 另一种简单粗暴（但可能同样有效）的策略是在一开始根据预估一次性将表建完（比如预估记录量为一千亿，则一次创建完一千张表）。这对于内部使用的短链接系统尤为有效。

> 用 crc32 值而不是长链接本身去查数据库的另一个好处是大大提升了查询性能。因为 crc32 值可能碰撞（重复），所以实际查询是根据 crc32 和长链接本身一起查，用的 crc32 值字段的索引。

### 查询缓存
长短链接的映射关系基本不会改变，该特性很适合做缓存，实际系统需保证 99% 以上的缓存命中率。

因为查询主要集中在短链接到长链接映射这个方向，所以我们只做这个方向的缓存：用 flag 生成 key，对应的 url 作为 value。

对于缓存穿透问题，我们使用 Redis 的布隆过滤器解决。当未查到缓存时，先检查布隆过滤器，如果其告诉我们不存在，则一定不存在，如果告知可能存在，则再去查数据库。

> 对于长链接到短链接的查询也采用布隆过滤器。在生成短链接之前，需要检查对应的长链接有没有已经生成短链，此时我们先查布隆过滤器，如果其告知不存在，则无需再检查数据库（因为绝大多数时候调生成接口都是为新 url 生成短链接，所以布隆过滤器能过滤掉绝大部分的数据库查询）。
>
> 另外我们用 lua 脚本将多次 Redis 操作打包成一次原子操作以提升性能。

> 关于本地缓存：
> 本设计未引入本地缓存（业务服的本地内存缓存）。引入本地缓存会带来额外复杂度，而且因为短域名系统的大体量数据，本地缓存不可能缓存全部数据，这可能导致频繁的缓存失效，造成极低的缓存命中率（或者加大本地缓存内存空间，但这会带来很大的资源开销，假如一条记录 300 字节，1 亿条记录每台服务器至少需要 28G 内存）。
> 但这不代表实际系统一定不能用本地缓存，比如我们可以人工标识哪些 url 启用本地缓存，或者根据统计数据由系统自动决定哪些 url 启用本地缓存。只是对于一般的短域名系统，Redis 缓存足够了。

### 安全
本系统提供的两个接口都应该是授权型的（如简单的 appid+secret、JWT 等），不可公开访问，这样杜绝了公开的暴力攻击。

但即便这样，也不能保证被授权的调用不会恶意攻击，或者因调用方程序 bug（或不恰当的使用方式）导致暴力调用从而拖垮系统。所以还应该对调用频次执行限流措施。

> 一般采用多级限流方案，如创建接口一个 appid 一分钟不能超过 5000 次，1 小时不能超过 100000 次。
> 实际限流方案可能根据调用方等级有所不同。
> 
> 注：本次代码未实现鉴权和限流。

另外前面提到的校验和和布隆过滤器也加强了系统安全性。

### 架构图（概要）

### 流程图：创建短链接

### 流程图：根据短链接查询对应的长链接

### 单元测试
所在目录：test/unit。

### 集成测试
所在目录：test/integration。

包括三种集成测试：数据库操作（models 下面的代码）、Redis 操作（libs/cache.ts 的代码）和 API 接口。

### 测试覆盖率






