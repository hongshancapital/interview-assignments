#短链接服务
本文主要介绍文件内容组成，设计思路和技术点，压测场景分析
***
##文件内容
文件结构分成两个部分  
1、src目录：包括所有的短链接服务的源代码内容  
2、资料图目录：包括架构设计图、jacoco覆盖率图、jmeter压测图

##设计思路
短链路服务的核心技术点在于根据url生成短码，并且将短码和url的映射保存包内存缓存中。需要考虑如下几个方面的内容  
###短码生成
短码生成算法一般有两种md5和自增序列，本次使用的是自增序列算法，考虑到md5算法，因为md5固有的散列值冲突问题需要解决，会比较麻烦，暂不予考虑。
自增序列算法设计思路借鉴了snowflake算法的思想，因为最终的短码是8位，短码包括的字符种类有0-9 a-z A-Z，有62个，可能的种类数是62^8。
相对应的2进制范围是(2^47, 2^48)，可以拆解为  
时间序号(38位)+工作id(3位)+递增序号(6)
* 时间序号(38位) 记录当前时间和2022-01-01 00:00:00 之间的毫秒的差值，目前可以支持10年
* 工作id(3位) 初始值位0，如果发生时间回拨，累加1，如果>=2^3，从0开始
* 递增序号(6) 遇到同一毫秒相同时，递增的序号  

最终支持的短链接个数是2^44  

需要解决的问题  
***时间回拨***  
因为每次生成下一个序号的时候，需要比对上次更新的时间戳，在判断上次更新时间戳比本次要大时候，累加工作id，如果工作id大于7，工作id设置成0  
因为时间回拨是小概率事件，所以不会存在时间回拨发生集中在某一个时刻多次发生，累加工作id可以解决；即使工作id重新设置为0之后，即使以前发生时间回拨，
当前时间相比于以前发生时间回拨的时间也大了很多，所以也不存在重复的情况  
***时间冲突***  
最后的递增序号6位，在访问量大的时候，可能会超过最大值，目前超过最大值的时候，会直接sleep 1ms，然后再次获取新的序号

***转换为短码***  
因为得到的值比long的最大值要小，直接使用long获取就行，然后转换成62进制，通过取余的算法即可

###短码存储
使用了guava中的localCache，是支持lru算法的。内存会保存url到短码的映射和短码到url的映射，保存url到短码的映射是为了保证存储接口访问的时候做到幂等

###高可用
为了避免机器流量大的时候，保证可用性，使用了单机限流，限流算法使用了令牌桶算法，直接使用guava包中的令牌算法

###并发问题
存在一种情况，存储接口同时有两个相同的请求，url相同，需要做到并发的问题，使用了分段锁，分成CPU核数个锁，通过url的hashcode%锁个数，加相应的锁

###其他
因为内存缓存会自动删除很久未访问数据，所以使用获取接口时，如果查询不到数据，直接返回短链接过期的错误。

##压测场景
本次压测有三种  
1、单独压测存储接口  
2、单独压测获取接口  
3、模拟实际生产场景，10%存储接口，90%获取接口  
说明：目前只有一台单机，无法测试压测情况下效果，正常一台这种简单服务场景下，单机支持1-2wQPS是没有问题的，因为window存在机器端口号不能直接重用的问题，需要多台机器才能更好测试。
