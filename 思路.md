需求：
    短域名存储接口：接受长域名信息，返回短域名信息
    短域名读取接口：接受短域名信息，返回长域名信息
要求：
    1.短域名长度最大为 8 个字符；
       技术调研：
         网上比较流行的算法有两种 自增序列算法、 摘要算法
            算法一：
                自增序列算法，也叫永不重复算法，设置ID自增，再利用的就是低进制转化为高进制时，字符数会减少的特性，将10进制转换为62进制。
                需求是最大为8字符，62进制大概有62^8 ~= 200万亿种组合，够用了。
            算法二：
                第一种方式：
                  简单长链接进行加盐md5，生成32位字串，随机取6个字符，或者简单粗暴取最后6位，但是md5只包含0-9A-Fa-f,
                  比字母表的里面字符还少，冲突几率更大！
                第二种方式：
                  1.将长网址 md5 生成 32 位签名串,分为 4 段, 每段 8 个字节
                  2.对这四段循环处理, 取 8 个字节, 将他看成 16 进制串与 0x3fffffff(30位1) 与操作, 即超过 30 位的忽略处理
                  3.这 30 位分成 6 段, 每 5 位的数字作为字母表的索引取得特定字符, 依次进行获得 6 位字符串
                  4.总的 md5 串可以获得 4 个 6 位串,取里面的任意一个就可作为这个长 url 的短 url 地址
            对比：
                第一种算法只要解决自增id问题就可以避免冲突，自增id可以采用数据库自增主键，每次生成短码只需一次操作，有一个不太好的地方就是出现的短码是有序的，可能会不安全。
                第二种依赖于程序随机，容易出现冲突，这就需要每次在存储的时候判重，效率低一些。
            安全：
                短链接虽然方便了传输和记忆，但是由于链接组成的字符个数少，更容易被爆破、猜测攻击，攻击者可以轻松遍历所有字符组成的链接
                所以不建议使用短链接发送具有私密性的网址，比如说重置密码链接，对一些权限、敏感信息的链接要做好二次鉴权
       思路：
            综合考虑，第二种算法因为Hash冲突是不可控的。当然，我们有解决Hash冲突的N种方法，但是这只会增加系统的复杂度。
            决定使用自增序列算法；
                考虑使用推特的雪花算法，之后因时钟回拨，序列浪费而放弃。
                之后使用单机版JAVA的ID自增序列，简单，实用。设置起始偏移量（第五位开始14776336），短码位5～8位，大概有200万亿个。
                考虑到顺序短码的不安全性，让62位对有序短码不按照顺序排列处理。

    2.采用SpringBoot，集成Swagger API文档；
        直接使用技术栈

    3.JUnit编写单元测试, 使用Jacoco生成测试报告；
        直接使用技术栈

    4.映射数据存储在JVM内存即可，防止内存溢出；
        考虑使用JVM内存，参考实现hutool的TimedCache让用户自定义存储过期时间，用ScheduledFuture来控制。
        而后监控内存使用量，设置阈值，超过阈值，停止短网址生成。


一些想法：
    考虑安全，可以加入验签，敏感链接可以加入密码
    还有根据实际场景做一些容量和约束

    此服务应该是频繁读操作。相比起加入新的URL而言，访问已有URL的短链接将会频繁很多。
    我们可以假设读写操作的数量比为100:1。

    流量估计
    每月生成500M个新的短URL，每秒~200
    读写操作数量比100:1
    每月重定向（读）为500Mx100=50B， 每秒~20K

    存储估计

    假设每个短URL以及原始链接会被保存5年，5年内生成的短URL总量为500Mx5x12=30B
    假设每个URL需要500B，总共需要的存储空间为500Bx30B=15TB

    带宽估计
    每秒会有~200写操作（新URL），所以总共上传数据带宽为100KB/s
    对于读操作，~20K/s，下载带宽为~10MB/s

    访问分析


