# 短域名服务设计文档

## 需求分析
### 原始需求
撰写两个 API 接口:
- 短域名存储接口：接受长域名信息，返回短域名信息
- 短域名读取接口：接受短域名信息，返回长域名信息。

### 注意事项
- 短域名长度最大为 8 个字符
- 映射数据存储在JVM内存即可，防止内存溢出

## 设计
### 短域名算法方案
#### 方案1：自增序列算法
- 方案描述：通过发号器，生成唯一的序列与长域名一一对应
- 优势：生成的短域名具有唯一性
- 不足：因为自增序列的存在，要考虑数据一致性问题。按CAP原理，在高并发、分布式场景下，序列生成的性能存在瓶颈，要花费较大代价进行数据一致性、容灾等方面的设计。

#### 方案2：哈希算法
- 方案描述：通过哈希算法，给长域名生成一个短哈希值
- 优势：解决了方案1的不足，不受CAP原理约束，通过增加集群节点即可实现写性能的提升
- 不足：哈希算法存在碰撞冲突

#### 结论：
需要根据应用场景、访问规模，选择合适的算法。本应用采用方案2，详细如下：
- 哈希算法选择：采用非加密哈希算法，要求生成速度快。可选的有MurmurHash、CityHash。由于java语言官方暂时只实现了MurmurHash，本应用选用MurmurHash。
- 可支持的短域名数量：[0-9a-zA-Z]，每个占位有62个字符可选，支持62^8=218340105584896,约218万亿个
- 哈希bits转换为字符：哈希长度采用128位，每16位为一组，转INT后(左侧2位置0，防止负数)，除以62取余数，获取index对应的字符

### 缓存使用
- 缓存中间件：本次暂只支持单机，因此选用guava作为内存缓存。采用LRU算法进行缓存淘汰。
- 缓存大小：限制最长域名为1024字符，则每个域名映射需占用空间=(1024+8)*2=2064字节。使用1/3的jvm内存作为短域名缓存，程序每次启动时，动态获取并计算出可以存储的个数。

### 设计中遗留问题的思考
- 哈希冲突：本次设计，忽略了哈希冲突。如果要解决这个问题，可以采取hash+linkedlist方式，生成短域名后如果检测出碰撞，则在短域名末尾增加一位index，用以标记碰撞列表的位置。由于MurmurHash是充分散列的，可以保障碰撞列表不会太长。
- 缓存
  - 缓存过期后，无法查到对应长域名：增加持久化层，对于已过期、非热点数据，需要查询持久化层
  - 缓存数量计算方式的优化：本次缓存预估，粗暴的取了最长域名为1024来计算。可以优化为按实际长度来算，充分利用内存资源。

## 测试