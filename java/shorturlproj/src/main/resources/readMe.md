#短域名服务说明文档
##1. 设计思路
###（1）总体设计
    对外暴露短域名服务接口，实现长短域名的转换，接口中包含两个方法：  
        * 短域名存储方法：接受长域名信息，返回短域名信息，  
        * 短域名读取方法：接受短域名信息，返回长域名信息。  
        
###（2）短域名存储方法
    功能：将收到的长域名转换成短域名，并将短域名——长域名的关系存储在缓存中，返回转换后的短域名。
    参数：longUrl，长域名，String类型
    返回值：shortUrl，转换后的短域名，String类型
    
    短域名生成采取发号方式，即每个长域名请求到来后为其提供一个按序增加的编号，根据编号值转换为短域名。
    
    长短域名对应关系存储考由于是放在JVM内存，虑到内存溢出和同步的问题，采用guava的Cache类型存储，设定最大容量为1000万，超出容量采用
    LRU方法替换，或1小时没有访问则自动回收空间，短域名作为Key，长域名为Value[^注1]。
    
    短域名可以使用的字符集为0-9、a-z、A-Z，因此编号到短域名的转换实际上是将编号值将10进制转换为62进制,由于短域名最大允许长度为8位，
    因此编号最大值为62^8 = 2,183,401,055,848,96[^注2]。考虑到线程同步，发号采用AtomicLong类型。
    
    使用Future接口调用callable接口的方式实现多线程生成短域名，GenerateShortUrl类为生成短域名的call方法的重写，通过future.get()
    方法获取生成的短域名，并返回
    
    [^注1]: 在初始设计中想让长短域名一一对应，即根据长域名生成短域名后，再次请求同样的长域名会返回相同的短域名，除了BiMap外实现Value
    到Key的反查性能消耗都很大，而BiMAP并非线程安全，ConcurrentMap在内存溢出方面不好控制，故选择Cache。由于通常以短域名访问长域名的
    请求数高于长域名生成，为了尽量减少反查，以短域名作为Key，后来在性能测试中发现反查的效率太低了，因此取消了反查，每次长域名过来都会
    生成新的短域名。
    
    [^注2]: 为了编号到域名转换方便，实际8位最大可实现的空间为62^8+62^7+...+62 = 221,919,451,578,090。
    
###（3）短域名读取方法
    功能：根据收到的短域名读出对应的长域名，返回长域名结果。
    参数：shortUrl，长域名，String类型
    返回值：LongUrl，转换后的短域名，String类型
    
    根据收到的短域名去Cache里面读出对应的长域名，返回长域名结果。如果没有对应的长域名则返回"短连接地址失效"。
    