# 短域名服务
所谓短域名服务，就是将长的URL网址，通过程序计算等方式，转换为简短的网址字符串。用户通过访问简短的网址可以实现对真实长网址的访问

# 作业需求
    撰写两个 API 接口:
        短域名存储接口：接受长域名信息，返回短域名信息
        短域名读取接口：接受短域名信息，返回长域名信息。
    限制：
        短域名长度最大为 8 个字符
        采用SpringBoot，集成Swagger API文档；
        JUnit编写单元测试, 使用Jacoco生成测试报告(测试报告提交截图即刻)；
        映射数据存储在JVM内存即可，防止内存溢出；

# 设计思路
    一、短链接转长链接算法(根据网上提供的方案)
       由[a - z, A - Z, 0 - 9]这62个字母与数字组成，长度最大为8位，可以生成出62^8个短链接
       1.通过自增id生成,缺点是短码有序容易被破解，优点是实现简单且不会出现重复
       2.通过摘要算法，缺点是实现稍微复杂一点且小几率存在碰撞的可能性，解决冲突会比较麻烦，优点是破解起来相对自增id会麻烦点
       3.普通8位随机数，生成简单。缺点是重复概率比较大。

       本人选择第二种，实现稍微复杂点，但是安全性更高。数据都存在内存中，读取速度快。

    二、如何解决重复添加相同长链接的问题
        生成的短链接都保存在内存中，通过内存去重避免短链接重复。

    三、如何防止内存溢出
       当内存达到上限的时候需要回收掉部分数据，数据去重判断以及长短连接对应考虑使用Map结构（时间复杂度O(1)）。guava包下Cache提供的缓存功能，
       线程安全，并且在内存不够时使用LRU算法清理数据,效率比较高。guava毕竟时内存级别的缓存解决方案，生产环境如果生成短链接需求很大，可以考虑使用
       redis代替。
# 单元覆盖率
    详见resource/static/覆盖率1.png,resource/static/覆盖率1.png
# 压测方案
    简单的通过spring提供的StopWatch做了一下接口请求统计
    以下是部分结果（一共发起了1万个接口请求，共执行了不到6秒的时间）,详细见resource/satic/压测.png
    ---------------------------------------------
    ns         %     Task name
    ---------------------------------------------
    000297800  000%  task_9986
    000294300  000%  task_9987
    000307400  000%  task_9988
    000305100  000%  task_9989
    000297900  000%  task_9990
    000288600  000%  task_9991
    000287900  000%  task_9992
    000295800  000%  task_9993
    000304200  000%  task_9994
    000297100  000%  task_9995
    000293900  000%  task_9996
    000297600  000%  task_9997
    000303400  000%  task_9998
    000309000  000%  task_9999
    000306800  000%  task_10000