# 域名转换接口设计

#### 服务地址

| 访问地址         | 端口 | 应用名  | 类别       |
| ---------------- | ---- | ------- | ---------- |
| http://localhost | 8080 | url-api | 短域名服务 |



#### swagger接口发布地址

本次任务设计的接口均集成了swagger接口发布文档，访问地址为：ip地址 + 端口号 + /swagger-ui.html

例：http://localhost:8080/swagger-ui.html

注：本次设计的接口均已使用swagger调试成功



#### 单元测试

本次设计的接口均已使用junit单元测试并通过，并且已使用jacoco生成测试报告，单元测试覆盖率截图如下：

![测试用例覆盖面截图](.\测试用例覆盖面截图.png)



#### 接口说明

本次作业主要实现了2个接口：

- 短域名存储接口：接受长域名信息，返回短域名信息
- 短域名读取接口：接受短域名信息，返回长域名信息。



#### 名词解释

长域名：指用户传入的原始域名

短域名：指使用长域名在服务中生成的短域名



#### 软件架构

本系统采用springboot框架，集成webmvc，swagger api文档，logback日志框架，junit进行单元测试，jacoco生成测试报告。



#### Api接口

| 接口路径         | 请求类型 | 参数                     |
| ---------------- | -------- | ------------------------ |
| /getShortUrl     | GET      | url （此处需传入长域名） |
| /findOriginalUrl | GET      | url （此处需传入短域名） |



#### 算法实现

此次长短域名转换，使用的是JVM内存来存储对应的数据，在Service内部维护了一个HashMap，用于存储所有被请求过的长域名以及短域名。先将传入的长域名通过MD5算法生成一个值，再通过固定的key前缀加上该值，在维护的HashMap中寻找对应的value就是短域名。若该长域名第一次进行请求，则通过一个自增变量生成一个不重复的key后缀（此处需要用到一个char数组来实现），再将固定的key前缀拼接上该key后缀，生成的短域名即可返回，并且在HashMap中将该长域名和生成的短域名分别保存。当我使用该短域名请求过来查询对应的长域名时，即可直接在HashMap中寻找，如果找不到，则直接返回空。以此来实现一个简单的域名转换，以及域名寻找的服务接口。



#### 待优化

若是在生产环境，或者条件允许，使用redis来代替Map来存储效率更高也更方便。因为不在同一个进程内运行，相互不影响，并且使用redis的increment自增函数来实现该功能更科学。若继续使用HashMap，可以考虑分成两个HashMap，一个专门用来存储短域名，另外一个专门用来存储长域名，这样查询起来效率更高。并且使用这种方式需防止内存溢出。