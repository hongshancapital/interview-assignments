##目录说明
> checkout
>校验信息类
>
> config
>统一全局处理和获取短链接处理类
>
>controller
>controller类
>
>service
>关键服务类
>
## 设计思路

-
1 长短链映射对应关系存在内存中，每个对应关系存2份，1份用长连接作KEY，短连接作VALUE，1份短连接作key，长连接做value。
2、转换链接使用GetshortUrl类，使用摘要算法生成短链接；
    a:初期考虑使用雪花算法和发号器，但是长度太大，使用62进制转换，长度超过8个字符；
    b:也可以使用 Redis、Snowflake 来实现发号器，但这些方案无疑会极大地增加系统复杂度，
    只有超大型规模的短网址项目才会考虑到。或者采用 uuid 的方式实现分布式的 ID 生成，
    但 uuid 的长度又有些过长了。
    c:保证同一个长地址，每次转出来都是一样的短地址；方案1：
    用key-value存储，保存“最近”生成的长对短的一个对应关系。注意是“最近”，
    也就是说，我并不保存全量的长对短的关系，而只保存最近的。比如采用一小时过期的机制来实现LRU淘汰;
    方案2：如果我们希望同一个长链多次转换的结果相同，那么查库显然比较低效，而缓存是 key-value 的，
    反过来查询 value 也很低效，这时就可以使用布隆过滤器。
    d：写个重定向方法，当前端传递短链接时，自动重定向到对应的长链接
3 通过2个RESTAPI来做短连接的生成存储和通过长连接获取短连接
4 如果在集群部署时，在高并发情况下可能会出现短连接碰撞并被覆盖的情况，需要使用分布式锁来保证安全性。
关于内存溢出：
	a：使用控制max_cache_size来硬性控制
	b: 或者采用caffeineCache 作为jvm级缓存，存储长短链接的映射。caffeineCache缓存可配淘汰策略
	c：控制long-url的字符数 （比如最长支持1000个字符）
