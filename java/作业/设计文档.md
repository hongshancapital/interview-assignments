# 设计文档
短域名系统，Java版本的设计文档


## 短域名算法实现
1. 要求域名短码最多8个字符串，一般通行做法是 [a - z, A - Z, 0 - 9] 总共 62 个字母组成的，所以 8 位的话，总共会有 62^8 ~= 200万亿种组合，这个数量级足够了。
2. 经过调研，主要的生成短码的方法有三种:
	* 自增id,每新增一个短码，就在上次添加的短码id基础上加1，然后将这个10进制的id值，转化成一个62进制的字符串。优点是无碰撞。缺点是短码的长度不固定，并且是有序的，可能会有安全问题。百度 和 yourls采用了这个算法。
	* 摘要算法，将长网址 md5 生成 32 位签名串,分为 4 段, 每段 8 个字节；对这四段循环处理, 取 8 个字节, 将他看成 16 进制串与 0x3fffffff(30位1) 与操作, 即超过 30 位的忽略处理；这 30 位分成 6 段, 每 5 位的数字作为字母表的索引取得特定字符, 依次进行获得 6 位字符串；总的 md5 串可以获得 4 个 6 位串,取里面的任意一个就可作为这个长 url 的短 url 地址。
	这种方式的优势是短码位数是比较固定的，弱点是还是会碰撞。有文章称微博使用该算法。
	* 随机算法，该方法是从62个字符串中随机取出一个6位短码的组合，然后去已有数据中中查询该短码是否已存在。如果已存在，就继续循环该方法重新获取短码，否则就直接返回。因为众所周知计算机的随机数是伪随机数的原因，碰撞的可能性不小，在数据比较多的情况下，可能要循环多次才能拿到一个可用的短码。
	
	最终决定，采取自增id法。为了让生成的短码看上去长度比较平均，因此初始值从一个比较大的值开始
	

	
## 自增id的实现
能够用在该场景下，不依赖其它程序，靠Java自己实现的自增id实现，有AtomicLong/LongAdder，snowflake，百度uid-generator。(美团Leaf需要额外部署MySQL)。
通过对比，单个snowflake服务进行序列自增时无法并发，如果想并发的话，必须额外部署多个snowflake服务。百度uid-generator部署较为麻烦，且如果不自己实现workerID分配器的话也必须依赖MySQL。所以最终决定采用AtomicLong实现。

如果只使用单个 AtomicLong/LongAdder 变量，则实际在取自增id的时候，实际只能单线程起效，这无疑降低的系统吞吐量
。所以为了增加系统吞吐量，参考了“基于数据库集群模式”的自增id方式，采用多个 AtomicLong 变量，步进数即是变量的数量。请求进入时随机选择一个 AtomicLong 变量获取id。






## 检测Url重复
除了建议 短链->长地址的 map映射外，需要一个方法，来过滤可能是重复的长地址，经过调研，有以下三种方案可选：
1. 再建立一个 长地址->短链 的map映射关系，这个方法非常精确，但是本质是空间换时间的方式。
2. 布隆过滤器，优点是非常省内存，精确度缺一点。但是缺陷是，不能直接从长地址得到短链。
3. LRU Map，只保留一段时间内写入的长地址，这样虽然不能做到百分百过滤，但是取得了一个相对平衡，即过滤了短期的大量重复长地址，又可以从长地址直接得到短链。

经过权衡，认为初始状态下，只需要屏蔽一段时间内重复的长域名即可，于是实现了LRU Map这个方案。




## 将来可能需要的安全验证
即使是加上重复url过滤，如果不加限制的使用，数据量也会高速的膨胀。调研得知新浪微博的短域名长度早就膨胀到了10位数以上，并且它们的短域名服务已经加上了每日每人使用量限制。
这里的需求上没个方面的要求，所以暂不实现。


## 测试方案
使用Jmeter在另外的电脑上发起测试，通过每秒QPS来检测性能

