**设计图和测试结果覆盖率等请查看png文件**


**设计思路**

**采用树状存储 TreeRepository**

1.定义树状存储结构，root节点无数据

2.每一个长链接按照字符在字符串中的出现顺序（1-n），处于树的第n层，节点有指向上一个子母节点的指针，维护一个所有子节点map，还有一个node本身的value也就是字母的值

3.叶子节点就是每个长链接的最后一个字母，比其他层的子节点多维护一个代表短链接的字符数组（短链接的值通过AbstractShorten生成）

4.这样每一个长链接会用树中一条从根节点到叶子节点的分支表示

5.每一个叶子节点对象会同时放入一个并发Map中，以便于通过短链接值快速找到对应的叶子节点，往上遍历到整个长链接的值



**注：**

1.尽量简化数对象的描述增加内存消耗，所以去掉了getter/setter，采用了public属性

2.节点对象中代表节点的值采用char基础类型

3.节点的子节点为了方便查找，使用了map，map的key是Character对象，从TreeRepository中possibleChars里面获取
(possibleChars是在TreeRepository中维护的一个possibleChars，里面是所有可能出现的字符对象，为了防止重复创建Character对象）

4.更改节点的过程要保证线程安全

**生成短域名的角色 AbstractShorten**

短域名生成有很多中方法，所以也需要抽象出来。 同理实际生成短域名的算法只关心计算，所以需要一个调用角色Shorten，Shorten拿剪刀(Scissor)对信息加工。
本项目实现给每一个url生成一个Long类型id，如果可用的字符数时62个，就将id装成这62个字符代表的62进制表示。根据最大id和最大id控制字符长度。



**性能测试相关**

Junit  ShortenUrlControllerTest.testLoop() 开启8个线程，并发不断请求获取短域名和长域名接口，assert长域名转短域名后，再获取长域名执行结果是否相等。

使用java客户端程序/或者jmeter等工具多线程并发连续请求，最开始只请求获取短域名，参数是随机生成的字符串拼接成的长域名，以生成短域名，不断对JVM对内存施压
但生成短域名的请求次数到达一定次数后，同一个客户端线程在发起生成短域名请求后，获得短域名地址，紧着着作为参数发起获取长域名的请求
过程中通过jmap命令和jconsole观察服务端的资源使用情况