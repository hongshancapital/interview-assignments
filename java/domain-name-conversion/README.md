# 短域名服务
所谓短域名服务，就是将长的URL网址，通过程序计算等方式，转换为简短的网址字符串。用户通过访问简短的网址可以实现对真实长网址的访问

# 作业需求
    撰写两个 API 接口:
        短域名存储接口：接受长域名信息，返回短域名信息
        短域名读取接口：接受短域名信息，返回长域名信息。
    限制：
        短域名长度最大为 8 个字符
        采用SpringBoot，集成Swagger API文档；
        JUnit编写单元测试, 使用Jacoco生成测试报告(测试报告提交截图即刻)；
        映射数据存储在JVM内存即可，防止内存溢出；
        
# 设计思路
    一、短链接转长链接算法(根据网上提供的方案)
       由[a - z, A - Z, 0 - 9]这62个字母与数字组成，长度最大为8位，可以生成出62^8个短链接
       1.通过自增id生成,缺点是短码有序容易被破解，优点是实现简单且不会出现重复
       2.通过摘要算法，缺点是实现稍微复杂一点且小几率存在碰撞的可能性，解决冲突会比较麻烦，优点是破解起来相对自增id会麻烦点
       3.普通随机数，缺点是碰撞的可能性比较多，感觉没有优点
       
       本人选择第一种，因为实现简单且不会出现重复。数据都存在内存中，内存容量有限，当内存容量达到上线会淘汰掉一部分数据，如果
       淘汰掉的数据又再次生成了一个对应的新的地址，那么之前用户得到的老的数据就会跳转到新的地址上，对用户来说体验是很差的
       
    二、如何解决重复添加相同长链接的问题
       由于将数据放到了内存中，内存容易有限，所以没有保证绝对的去重相同的长链接，只保证了最近添加的长链接可以的过滤
       
    三、如何防止内存溢出
       当内存达到上限的时候收回掉部分数据。所以使用到了guava包下提供的缓存功能，如果内存不够会基于内存容量尝试回收最近没有使用
       或总体上很少使用的缓存项，类似于hashmap,效率也比较高
       
# 压测方案
    由于没有特殊要求，只是简单的通过spring提供的StopWatch做了一下接口请求统计
    以下是部分结果（一共发起了1万个接口请求，共执行了不到5秒的时间）
    StopWatch 'myWatch': running time = 4904278500 ns
    ---------------------------------------------
    ns         %     Task name
    ---------------------------------------------
    142977900  003%  task1
    004071600  000%  task2
    002297500  000%  task3
    002363700  000%  task4
    002977800  000%  task5
    002316900  000%  task6
    002225500  000%  task7
    002757700  000%  task8
    002259600  000%  task9
    002354800  000%  task10
    002318600  000%  task11