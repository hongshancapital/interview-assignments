长域名转短域名服务设计文档
1.需求
	1.1 短域名存储接口：接受长域名信息，返回短域名信息
	1.2 短域名读取接口：接受短域名信息，返回长域名信息
	1.3 限制
		1.3.1 短域名长度最大为 8 个字符
		1.3.2 映射数据存储在JVM内存即可，防止内存溢出
		1.3.3 采用SpringBoot，集成Swagger API文档
		1.3.4 JUnit编写单元测试, 使用Jacoco生成测试报告(行覆盖率和分支覆盖率85%+)
2.设计方案
	2.1 首先为短域名生成长域名后缀字符，方案可采用哈希算法或者ID自增生成器
	2.2 为使域名字符长度不超过8个且合法，需要转化成62进制
	2.3 将生成好的短域名放入缓存，通过key-value方式存储，提高查询检索效率
	2.4 通过短域名返回长域名时，从缓存中获取
	2.5 为防止恶意查询攻击和提高查询检索效率，引入布隆过滤器，查询时从布隆过滤器判断是否存在。

3.流程图
见 《短域名获取长域名流程图.png》《长域名生成短域名流程图.png》

4.接口文档
	4.1 长域名生成短域名
	入参：
	{
		"longUrl":"" // 长域名

	}

	出参：
	{
		"code":200, // 响应码 200:成功，400:参数格式错误，500:服务存在异常
		"desc":"success",//响应描述
		"urlData":"" // 响应值

	}

	4.2 根据短域名获取长域名
	入参：
	{
		"shortUrl":"" //短域名

	}

	出参：
	{
		"code":200, // 响应码 200:成功，400:参数格式错误，500:服务存在异常,600:长域名不存在，或已过期
		"desc":"success",//响应描述
		"urlData":"" //响应值
	}

5. 方案说明
	5.1 短域名字符生成方案
		5.1.1 哈希算法：需要解决哈希冲突问题，同时因为有哈希计算，一定程度上会影响性能
		5.1.2 ID生成器：本次采用AtomicLong自增生成，存在缺点是对于同一个URL会生成不同的短域名
		5.1.3 ID生成器生产环境：mysql自增 ｜ redis 自增 ｜ ZK | 雪花算法。一般生产会使用redis组件，建议使用redis生产ID,同时性能也高，需要注意集群部署进行容错，最好采用多ID发号器，提高性能
	5.2 缓存选择
	    5.2.1 内存缓存：可选择性有ConcurrentHashMap、Guava Cache、Caffeine。根据要求需要控制内存，则需要过期策略，选择性能更高的caffeine
        5.2.2 生产环境：可以使用分布式缓存，如redis来实现




