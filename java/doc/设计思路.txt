一、方案选型

比较常见的短链接生成方式有两种。

1、自增id映射
通过一个自增的数字分配给对应的一个长链接，自增数字转化成62进制，简单实现可以使用数据库自增，分布式环境考虑高可用的zk、雪花或redis。
对于相同的长链接会生成不同的短链。

2、md5摘要
长链接通过md5生成32位字符串，拆分处理后得到4个6位字符串，取一个作为短链接，冲突概率很低。

这里使用md5摘要的方式简单实现短链生成，避免引入其他中间件。

二、性能优化

关于性能优化主要从生成短链和短链反查两个功能思考，对于短链反查由于是纯内存操作，而且是key-value的查询方式，没有太多可优化空间。
对于生成短链考虑过使用bloomFilter判断这个长链接是否已经生成过，如果已经生成过则通过长链接与短链的key-value映射直接找到对应短链返回，
节省一次计算，但考虑到占用空间过多，而重复长链接请求又不是一个正常业务场景，成本高收益小，故放弃。

三、难点思考

1、两个不同的长链接会不会返回相同的短链接？
有可能，并发情况下两个线程同时做生成短链操作，由md5计算后产生碰撞，生成了相同的短链接，同时从缓存中先执行get判断是否已经有生成的短链接，
都返回未查询到然后再执行缓存set操作，成功后返回相同的短链接。这种情况发生几率非常低，要同时满足并发请求与md5碰撞，但如果出现是业务上无法接受的，
比如生成短链后以短信、邮件的形式发给百万用户但点击后是错误地址。

    解决方案：
    1.加锁，get和set判断放在一个方法里，对性能稍有影响
    2.缓存自身提供类似redis的setnx操作，重复key在set时失败

2、容量预估
由于长链接的长度不定，jvm分配的内存也不定，所以只能预估，长链接假定64字节短连接固定6字节，100w数据66m内存，jvm分配2g内存基本不会出现溢出。
达到总容量的80%打印warn日志，防止日志打印过多，考虑增加对报警日志的降级。

3、过期策略
如果有数据库可以把所有生成的短链落库，缓存采用lru等过期策略，但对于纯内存服务如果达到容量采用lru并太合适，所以需要对缓存中的数据设置过期时间，
参考网上其他一些短链服务，设置1小时短链过期。

四、优化

1、解决md5碰撞问题
其实在原本的设计里并没有考虑长链接md5碰撞的情况，短链的生成是用md5后的生成4组短链key，如果两个链接生成的md5值前8位是相同的，
那么生成的4组短链里的第一组会冲突，这种情况只要判断出来继续取下一组就可以，除非4组全相同。

解决方案就是如果发现4组key全都无法使用，增加一个新的混淆字符串重新生成md5，可以把混淆字符串也做成数组，循环生成。

2、synchronized加在方法上范围过大，是否可以优化
之前的做法synchronized加在方法上，相当于对当前对象加锁，这样并发高的时候请求会排队，对性能有影响。如果使用synchronized(this)的方式同样
也会在当前对象上加锁，所以最好使用synchronized(obj)，我的场景是解决key冲突时的覆盖问题，所以最好在key上加锁，没有冲突时程序照常执行，
这样就能提供很好的并发性，所以使用String对象作为锁，这里的关键点在于key要使用intern方法，从常量池找到已有的字符串生成，如果使用new出来的String，
会导致加锁失败。

这里intern是native方法，高并发场景会不会导致cpu使用过高？会不会对性能造成影响，所以在本地进行了测试生成1亿的md5字符串，
使用intern和没有使用intern的方法对cpu没有影响，使用intern方法耗时会增加，但对于单次的生成短链请求几乎没有影响