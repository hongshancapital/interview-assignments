一、方案选型

比较常见的短链接生成方式有两种。

1、自增id映射
通过一个自增的数字分配给对应的一个长链接，自增数字转化成62进制，简单实现可以使用数据库自增，分布式环境考虑高可用的zk、雪花或redis。
对于相同的长链接会生成不同的短链。

2、md5摘要
长链接通过md5生成32位字符串，拆分处理后得到4个6位字符串，取一个作为短链接，冲突概率很低。

这里使用md5摘要的方式简单实现短链生成，避免引入其他中间件。

二、性能优化

关于性能优化主要从生成短链和短链反查两个功能思考，对于短链反查由于是纯内存操作，而且是key-value的查询方式，没有太多可优化空间。
对于生成短链考虑过使用bloomFilter判断这个长链接是否已经生成过，如果已经生成过则通过长链接与短链的key-value映射直接找到对应短链返回，
节省一次计算，但考虑到占用空间过多，而重复长链接请求又不是一个正常业务场景，成本高收益小，故放弃。

三、难点思考

1、两个不同的长链接会不会返回相同的短链接？
有可能，并发情况下两个线程同时做生成短链操作，由md5计算后产生碰撞，生成了相同的短链接，同时从缓存中先执行get判断是否已经有生成的短链接，
都返回未查询到然后再执行缓存set操作，成功后返回相同的短链接。这种情况发生几率非常低，要同时满足并发请求与md5碰撞，但如果出现是业务上无法接受的，
比如生成短链后以短信、邮件的形式发给百万用户但点击后是错误地址。

    解决方案：
    1.加锁，get和set判断放在一个方法里，对性能稍有影响
    2.缓存自身提供类似redis的setnx操作，重复key在set时失败

2、容量预估
由于长链接的长度不定，jvm分配的内存也不定，所以只能预估，长链接假定64字节短连接固定6字节，100w数据66m内存，jvm分配2g内存基本不会出现溢出。
达到总容量的80%打印warn日志，防止日志打印过多，考虑增加对报警日志的降级。

3、过期策略
如果有数据库可以把所有生成的短链落库，缓存采用lru等过期策略，但对于纯内存服务如果达到容量采用lru并太合适，所以需要对缓存中的数据设置过期时间，
参考网上其他一些短链服务，设置1小时短链过期。