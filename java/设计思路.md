```java
	/**
     * 短域名最大长度
     */
    private static final Integer MAX_LENGTH = 8;


    /**
     * 域名映射最大容量 此处手动设置，防止容器太大  内存溢出
     */
    private static final Long MAX_MAP_SIZE = 5000000L;

    /**
     * 长短域名映射集合   线程安全  shortUrl -> url
     */
    private ConcurrentMap<String,String> urls = new ConcurrentHashMap<>();

    /**
     * id 计数器
     */
    private static LongAdder count = new LongAdder();


@PostMapping("shorUrl")
    @ApiOperation(value = "短域名存储接口",notes = "接受长域名信息，返回短域名信息")
    public String getShortUrl(String url){
        synchronized (this){
            Set<String> keys = urls.keySet();
            // 判断是否存在
            Optional<String> first = keys.stream().filter(key -> urls.get(key).equals(url)).findFirst();
            if(!first.isPresent()){
                // 10进制转 62进制
                String shortUrl = ConversionUtil.encode(count.longValue(),MAX_LENGTH);
                //容器是否大于指定大小
                    if(shortUrl.length()>MAX_LENGTH||urls.size()>MAX_MAP_SIZE){
                        System.out.println(urls.size());
                        // 数量过大则进行循环覆盖
                        count.reset();
                        // 10进制转 62进制 此处 count 等于0
                        shortUrl = ConversionUtil.encode(count.longValue(),MAX_LENGTH);
                    }
                    urls.put(shortUrl,url);
                    count.increment();
                    return shortUrl;
            }
            return first.get();
        }
    }


 @PostMapping("url")
    @ApiOperation(value = "短域名读取接口",notes = "接受短域名信息，返回长域名信息。")
    public String getUrl(@Nullable String shortUrl){
        return urls.get(shortUrl);
    }
```



# 核心原理

1. **自增序列算法**

   设置 id 自增，一个 10进制 id 对应一个 62进制的数值，1对1，也就不会出现重复的情况。这个利用的就是低进制转化为高进制时，字符数会减少的特性

   短址的长度如果设为 8 位，而每一位是由 `[a - z, A - Z, 0 - 9]` 总共 62 个字母组成的，所以 8 位的话，总共会有 62^8 ~= 2千亿种组合，基本上够用了。此处仅仅长度为8.还可以加上长度为7、6、5、4、3、2、1的

   为何要用62？取url常用的链接字符[0~9a~zA~Z]，正好62

   **结论：取一个变量为0的数开始自增，把该变量由十进制转换为62进制作为短域名**



​		10000

| 进制 | 结果           |
| ---- | -------------- |
| 2    | 10011100010000 |
| 8    | 23420          |
| 10   | 10000          |
| 16   | 2710           |
| 32   | 9RG            |
| 36   | 7ps            |
| 58   | 3Yq            |
| 62   | 2Bi            |
| 64   | CcQ            |



1. 变量 id 计数器（count），全局且线程安全。每次存储短域名前count.increment()

2. 每次存储短域名需要加锁  synchronized{}。保证映射容器大小和 id 计数器（count）是相等的

3. 通过 MAX_MAP_SIZE（短域名最大长度8） 和 MAX_MAP_SIZE来控制容器的大小。当短域名的长度大于8或者手动指定容器大小等于容器时大小时。容器的key及短码会重头开始覆盖之前的。以此不断循环解决内存溢出问题。

   count.reset();：重置id后，进制转换后，map会不断循环











