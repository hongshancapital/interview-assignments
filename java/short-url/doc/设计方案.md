### 短网址设计方案

----

- ##### 编码长网址为短网址

  1. ##### 使用哈希算法

     **使用哈希算法计算出长网址的哈希值**：既然demo的所有数据都存储在内存中，为什么不直接使用一个基于内存的不断增加的ID发号器呢？反正项目重启所有数据都会丢失，不存在生成的ID重复导致长网址不同但短网址相同的情况。但会出现一个长网址多次请求，会缓存不同的短网址这种情况。

     虽然用户不在乎这种事，对他们没有影响，但在实际项目中数据需要落库的时候，这就是一堆无效的冗余数据了，并且被恶意攻击或者生成短网址的调用方错误操作（代码漏洞等）还会导致这种无效数据存在的非常多。

     在使用ID发号器的情况下如何保证一个长网址对应一个短网址？

     1. 将长网址作为缓存（Redis或JVM内存）的Key，每次都判断下这个长网址是否存在。

        我们不能控制长网址的长度，并且在正常情况下需要编码的网址应该会很长的。不管是在Redis还是内存中，拿一个不可控的长字符串当Key都是不可行的；不但浪费了宝贵的内存资源还效率低下；

     2. 实际项目中，这些数据肯定都会落库，持久化存储。但是拿一个很长的字符串去数据库中做等值匹配，即使给长网址字段上了索引，也同样是一个效率低下的操作；并且也会导致增加、删除性能的降低；

     3. 如果说把上面的两种操作中的长网址改为长网址对应的哈希值，也是一种方案，但需要注意两个长网址不同但哈希值相同这种微小概率的发生；

     综上考虑，反正不管如何都需要用到长网址的哈希值，并且使用ID发号器还需要确保其是健壮的高效的，不可以生成重复值的。所以在本Demo中直接使用 `MurmurHash` 算法计算出长网址的哈希值来当做长网址对应的ID（但实际中不能用来当作数据库主键，因为它不是保持增长的），MurmurHash算法在计算速度和哈希冲突概率上都表现的很好，并且被广泛使用。本着最坏的打算就算哈希冲突的概率小但也是有概率的，所以Demo中使用一个类把长网址包装起来，同时类中还有一个int类型的code字段，当出现哈希冲突了，且两个长网址不一样，就让code累加一个不变的值。然后递归重新计算直到哈希不冲突为止。（demo中实际计算的是这个自定义类的哈希值）；也可以在长网址的头加一些其他的字符串（这种方案需要在比对长网址时，先把头部加的字符串去掉）

  2. ##### 使用hashids将唯一的哈希值编码

     如果直接使用哈希值当做短网址，不够复杂，存在安全问题；并且也略长。使用hashids可以将一个任意正整数转换为指定位数的字符串的可逆算法，并且基于 `salt` 安全性也有保障。并且它生成的字符串也不会发生碰撞，当数字过大无法用指定位数的字符串表示的时候会自动增加一位。它生成的字符串长度够短，并且也比纯粹的哈希值复杂，很适合当做短网址使用。所以使用hashids编码哈希值的结果作为短码

  3. ##### 布隆过滤器做第一层的过滤（可选）

     模拟直接落库存储，没有Redis，Memcache等内存缓存的情况下，使用布隆过滤器可以做第一层过滤，当结果是不存在，那么它一定是不存在的就可以直接返回了，不用去库里查了（但不能做到删除的情况）。如果过滤器结果是存在，它很大的可能是存在的（误判的可能性很小）可以进行查库的操作了。但实际项目中会使用Redis，还存在删除的情况，过滤器就可不用了。

  4. ##### 本次编码的长网址与缓存中此短码对应的长网址做对比。如果缓存中存在值且相同的话，直接返回短网址；如果与缓存中存在的值不同的话，说明冲突了，按照第1条的方案解决；如果缓存中没有对应值，说明是新的长网址，先缓存起来再返回短网址

  5. ##### 并发导致的线程安全问题

     在高并发情况下，假设请求A和请求B同时要将不同的长网址编码为短网址，但两个长网址恰好哈希冲突了。又恰好两个请求也都从缓存中查询到这个新的短网址不存在，需要缓存起来。这种情况下，当两个请求开始向缓存中存储数据，先缓存的数据就会被后缓存的数据覆盖掉。

     在实际的项目中，直接落库的话会存在两个短网址一样，长网址不一样的数据。引发了线程安全问题。

     解决方案：在生成短网址后，将判断缓存中有没有数据及缓存短网址的代码块使用 `synchronized` 锁起来，锁住的对象就是这个短网址，这样当短网址不同时，可以并发操作，当短网址相同时两个请求线程先拿到锁的先执行，后执行的在查询时就会发现短网址存在了。这样既保证了超大多数情况下的效率，有解决了几乎为0的概率下的线程安全问题。

     在实际项目中使用分布式锁解决此问题。

  6. ##### 基于JVM内存，如何防止内存溢出

     1. 使用LRU算法将缓存中最近最久未使用的长网址丢弃掉，或者其他的算法将缓存中的网址丢弃掉；保证新的长网址能缓存起来。

        如果采用此种方案，随着项目的运行，被丢弃的缓存越来越多。而在实际情况中也不会允许为了保证程序的正常允许，把一些重要数据删除。如果底层还有数据库做持久化存储情况下，可以使用此方案做二级缓存。

     2. 当JVM内存不够用了，就停止缓存，编码接口返回错误信息，保证解码及重定向接口的正常访问。

     解决方案：

     使用软引用的特性，当JVM内存不够用的时候，会回收软引用对象。创建一个软引用对象，在编码的接口中，先判断这个软引用对象有没有被回收，如果被回收了，说明内存不够用了，就直接返回错误信息。停止编码服务。
     在正常情况下，JVM内存比较大时（比如几个G），修改启动参数 `-XX:PretenureSizeThreshold` 和 `-XX:+UseSerialGC`，设置直接进入老年代对象的大小，让软引用对象直接进入老年代。并且这个对象尽量大一些（比如几十M），除了给程序留一些内存外，还要防止在高并发情况下，多个请求先判断软引用对象不为null，但实际上内存只够缓存一个请求的数据，如果设置的小了，可能回收的内存并不够其余请求所需要的缓存空间。

     经测试，启动时设置 `-Xmx32m` ，软引用对象占用1M内存 `new SoftReference<>(new Byte[1048576]);` 的情况下，达到预期效果

     ![](https://z3.ax1x.com/2021/07/08/RXGCad.png)

     此时访问其他接口正常。

- ##### 解码短网址为长网址

  1. 先拿着短网址去布隆过滤器中过滤下，进行初次判断，如果布隆过滤器的结果是不存在，说明这个短网址是错误的，直接返回错误信息
  2. 如果布隆过滤器返回的是存在，这时可以去缓存中找其对应的长网址了，再根据缓存的返回结果判断，如果为null，返回错误信息；否则返回对应的长网址

- ##### 短网址重定向

  1. 调用 `解码长网址为短网址` 的方法，获取到缓存对应的长网址，如果长网址为空，说明是一个错误的请求，直接设置Response的状态码为404。

     实际项目中还可以设置自定义404页面，同时为防止被远程机器随机生成短码撞库请求，可以针对请求机器的IP地址和404次数做限流或黑名单操作

  2. 如果缓存中有对应的长网址，那么给Response设置Location，让其重定向到对应的真实长网址，并且设置状态码为 `301` 告诉浏览器这是一个永久的重定向，下次再访问同一个短网址时，就可以直接跳转，不用再重新访问接口解析了

