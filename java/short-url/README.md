#短域名服务 工程

需求：
撰写两个 API 接口:

1.短域名存储接口：接受长域名信息，返回短域名信息
api 接口：http://127.0.0.1:8080/t/getShortUrl
method:POST 请求
param: String:originalUrl  非空
返回 json数据
{
code:  0,
message: "success",
data:"YfqiXVpA"
}
异常
{
code:  1,
message: "",  //错误信息
data:""
}
2短域名读取接口：接受短域名信息，返回长域名信息。
api 接口：http://127.0.0.1:8080/t/getOriginalUrl
method:GET 请求
param: String:shortUrl
返回 json数据
{
 code:  0,
 message: "success",
 data:"https://zhuanlan.zhihu.com/p/194199097"
}
异常
{
code:  1,
message: "",  //错误信息
data:""
}
限制：

短域名长度最大为 8 个字符   (短域名最大8个字符)
采用SpringBoot，集成Swagger API文档；
JUnit编写单元测试, 使用Jacoco生成测试报告(测试报告提交截图即刻)；  （只测试主要方法,异常情况）
映射数据存储在JVM内存即可，防止内存溢出； （采用caffeine来控制内存容量，淘汰过期数据）

设计思想：

ShortURL[http://www.xxx.com]是一个在线web服务。它能将你任意输入的url简化一个由http://www.xxx.com/和一个随机字符串组成短url.访问短url会经过http://www.xxx.com服务跳转至长url.
比如，http://blog.csdn.net/bdss58经过短化后，生产http://www.xxx.com/y9abtgrp。在浏览器输入http://www.xxx.com/y9abtgrp，会自动跳转http://blog.csdn.net/bdss58。


短网址服务的两种实现方法
原理 :当前互联网上的网页总数大概是 45亿，45亿超过了 2^{32}=4294967296232=4294967296，
但远远小于62位整数的上限值，那么用一个62位整数足够了。
微博的短网址服务用的是长度为7的字符串，
这个字符串可以看做是62进制的数，那么最大能表示{62}^8=3521614606208627=3521614606208个网址，
远远大于45亿。所以长度为8就足够了。一个64位整数如何转化为字符串呢？
，假设我们只是用大小写字母加数字，那么可以看做是62进制数，
log_{62{(2^{64}-1)=10.7log62(264−1)=10.7，即字符串最长11就足够了。
实际生产中，还可以再短一点，比如采用的长度就是8，
因为 62^8=3521614606208627=3521614606208，
这个量级远远超过互联网上的URL总数了，绝对够用了。现代的web服务器
（例如Apache, Nginx）大部分都区分URL里的大小写了，
所以用大小写字母来区分不同的URL是没问题的。因此，正确答案：
长度不超过8的字符串，由大小写字母加数字共62个字母组成

能实现的思路有大致有四五种：
考虑的问题，高并发，缓存，分布式，批量发号
1，分布式无碰撞短码生成算法，内存发号，批量预先生成，保证无碰撞
，缓存取号，生成的号在容量范围内
2.自动过期策略

第一种实现方法思路是通过 ID 生成器来生成短网址。
1.我们维护一个 ID 自增的 ID 生成器，给每个原始网址分配一个 ID 号码，
并且同样转成 62 进制表示法，拼接到短网址服务的域名之后，形成最终的短网址
我们可以维护一个 ID 自增生成器。它可以生成 1、2、3…这样自增的整数 ID。当短网址服务接收到一个原始网址转化成短网址的请求之后，它先从 ID 生成器中取一个号码，然后将其转化成 62 进制表示法，拼接到短网址服务的域名（比如http://t.cn/）后面，
就形成了最终的短网址。最后，我们还是会把生成的短网址和对应的原始网址存储到数据库或nosql中
2.需要实现高性能的ID生成器，并保证不重复（加锁）
第一种思路：我们可以给 ID 生成器装多个前置发号器。我们批量地给每个前置发号器发送 ID 号码。当我们接受到短网址生成请求的时候，就选择一个前置发号器来取号码。这样通过多个前置发号器，明显提高了并发发号的能力
第二种思路：直接实现多个 ID 生成器同时服务。为了保证每个 ID 生成器生成的 ID 不重复。我们要求每个 ID 生成器按照一定的规则，来生成 ID 号码。比如，第一个 ID 生成器只能生成尾号为 0 的，第二个只能生成尾号为 1 的，以此类推。这样通过多个 ID 生成器同时工作，也提高了 ID 生成的效率
随机字符串由大小写字母和数字组成,表示62进制
----------------------------------------------------------------------------------------------------------------------------------
"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
"0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
---------------------------------------------------
分布式id 算法，可以采用 分布式唯一id：snowflake ,

基于自增序列 ： 这种算法实现比较简单，碰撞的可能性为0，可表达的URL可达无穷大，长度从1开始

考虑一种简单的实现 因为要控制在8 个字符
实现方法思路二 
短8位UUID思想其实借鉴微博短域名的生成方式，但是其重复概率过高，
而且每次生成4个，需要随即选取一个。
本算法利用62个可打印字符，通过随机生成32位UUID，
由于UUID都为十六进制，所以将UUID分成8组，每4个为一组，
然后通过模62操作，结果作为索引取出字符，

映射数据存储在JVM内存即可，防止内存溢出；
映射数据存放在本地缓存 caffeine,利用其可以设置容量大小跟当缓存容量超过指定的大小，缓存将尝试逐出最近或经常未使用的条目，防止内存溢出
这样重复率大大降低,考虑并发问题，用多个服务分批量产生8位短域名，放到list里面
映射关系存到redis缓存跟DB/nosql里面
