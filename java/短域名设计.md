### 短域名服务设计

#### 1.实现原理

1、接收长域名，同时该域名会对应一个自增的长整形ID，该ID其初始值为-1，接收第一个长域名后其值自增为0；然后0与有62取余得0，这个0将对应由A-Za-z0-9共62个乱序字符组成的字符数组的第0号下标对应的字符，该字符即为其接收的长域名对应的短域名

2、使用Map保存长域名与短域名的映射；同时用另一个MAP保存短域名与长域名的映射，以空间换时间，避免短域名到长域名映射要花大量的循环查找。

3、按需求其最多能存62的8次方个短域名。

#### 2.长域名到短域名映射流程图

### ![image-20211114213321824](https://cdn.jsdelivr.net/gh/yjwidr/diagarm/img/image-20211114213321824.png)



#### 3.短地址到长地址映射流程图

![image-20211114215107152](https://cdn.jsdelivr.net/gh/yjwidr/diagarm/img/image-20211114215107152.png)



#### 4.分层架构图

此系统为单体架构，其短域名映射都保存在同一个JVM进程中，若序号从1开始跑完62的8次方个映射，若每个K,V平均占5个字节，则需要992TB的内存空间，所以不可能在内存中把这个映射跑满。

![image-20211114223112884](https://cdn.jsdelivr.net/gh/yjwidr/diagarm/img/image-20211114223112884.png)

#### 5.性能测试



长域名到短域名接口，1000并发线程，每个线程跑2000次，总共跑200万次，长地址参数用jmeter的Randam函数助手生成${__Random(1,20000000,)}

##### 1.线程组配置

![image-20211120193309887](https://cdn.jsdelivr.net/gh/yjwidr/diagarm/img/image-20211120193309887.png)

##### 2.正则表达式提取器

使用正则表达式提取器Regular Expression Extrator 获取长域名转短域名后的结果，将提取的结果给短域名转长域名的接口做为参数，参数配置如下：

![image-20211120193443710](https://cdn.jsdelivr.net/gh/yjwidr/diagarm/img/image-20211120193443710-16374080927741.png)

##### 3.性能测试报告

![image-20211120193610405](https://cdn.jsdelivr.net/gh/yjwidr/diagarm/img/image-20211120193610405.png)

在1000个并发个，两个接口的吞吐率都在每秒18000以上。95%的响应时间在54毫秒，如上图所示。

跑完200万个随机数最后统计Map里有190万个Key，就是说生成200万的随机请求参数有10万请示参数是重复的。重复率为5%。

这个性能测试报告说明这个吞吐率是很高的。

假设一个K,V键值对平均占用5个字节，那么62的8次长域名对短域名的映射共占用992TB，反过来短域名到长域名的映射也是同样的空间。这个空间是很大的，实际线上项目肯定使用第三方外部缓存来处理的。肯定没有这么大的堆内存只能存在外部内存或者分片式的数据库中

#### 6.Swagger-ui

1.访问地址：http://localhost:8080/swagger-ui/#/

2.count接口是在跑完映射后查看长短地址映射的接口

3.另外两个接口分别是长地址和短地址互换的接口

![image-20211120195020897](https://cdn.jsdelivr.net/gh/yjwidr/diagarm/img/image-20211120195020897.png)

#### 7.单元测试覆盖率

使用jacoco做覆盖率测试，如下图：

![image-20211120201202945](https://cdn.jsdelivr.net/gh/yjwidr/diagarm/img/image-20211120201202945.png)

