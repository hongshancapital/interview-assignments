plugins {
	id 'org.springframework.boot' version '2.6.1'
	id 'io.spring.dependency-management' version '1.0.11.RELEASE'
	id 'java'
	id 'jacoco'
}

group = 'com.scdt.shorturl'
version = '1.0.0'
sourceCompatibility = '11'

processResources {
	filesMatching('application.yml') {
		expand(project.properties)
	}
}

allprojects {
	repositories {
		maven {
			url 'https://maven.aliyun.com/repository/public/'
		}
		mavenLocal()
		mavenCentral()
	}
}

dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-webflux'
	implementation 'org.springdoc:springdoc-openapi-webflux-ui:1.6.1'
	implementation 'org.slf4j:slf4j-api:1.7.7'

	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testImplementation 'io.projectreactor:reactor-test'
}

test {
	useJUnitPlatform()
}

tasks.withType(JavaCompile) {
	options.encoding = "UTF-8"
}




//======================Jacoco==============================

// Do not generate reports for individual projects
tasks.named("jacocoTestReport") {
	enabled = false
}

// Share sources folder with other projects for aggregated JaCoCo reports
configurations.create('transitiveSourcesElements') {
	visible = false
	canBeResolved = false
	canBeConsumed = true
	extendsFrom(configurations.implementation)
	attributes {
		attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
		attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
		attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'source-folders'))
	}
	sourceSets.main.java.srcDirs.forEach {
		outgoing.artifact(it)
	}
}

// Share the coverage data to be aggregated for the whole product
configurations.create('coverageDataElements') {
	visible = false
	canBeResolved = false
	canBeConsumed = true
	extendsFrom(configurations.implementation)
	attributes {
		attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
		attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
		attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'jacoco-coverage-data'))
	}
	// This will cause the test task to run if the coverage data is requested by the aggregation task
	outgoing.artifact(tasks.named("test").map { task ->
		task.extensions.getByType(JacocoTaskExtension).destinationFile
	})
}



// A resolvable configuration to collect source code
def sourcesPath = configurations.create("sourcesPath") {
	visible = false
	canBeResolved = true
	canBeConsumed = false
	extendsFrom(configurations.implementation)
	attributes {
		attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
		attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
		attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'source-folders'))
	}
}

// A resolvable configuration to collect JaCoCo coverage data
def coverageDataPath = configurations.create("coverageDataPath") {
	visible = false
	canBeResolved = true
	canBeConsumed = false
	extendsFrom(configurations.implementation)
	attributes {
		attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
		attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
		attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'jacoco-coverage-data'))
	}
}

// Task to gather code coverage from multiple subprojects
def codeCoverageReport = tasks.register('codeCoverageReport', JacocoReport) {
	additionalClassDirs(configurations.runtimeClasspath)
	additionalSourceDirs(sourcesPath.incoming.artifactView { lenient(true) }.files)
	executionData(coverageDataPath.incoming.artifactView { lenient(true) }.files.filter { it.exists() })

	reports {
		// xml is usually used to integrate code coverage with
		// other tools like SonarQube, Coveralls or Codecov
		xml.required = true

		// HTML reports can be used to see code coverage
		// without any external tools
		html.required = true
	}
}

// Make JaCoCo report generation part of the 'check' lifecycle phase
tasks.named("check") {
	dependsOn(codeCoverageReport)
}