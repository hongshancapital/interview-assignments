问题条件：
实现短域名服务（细节可以百度/谷歌）
撰写两个 API 接口:

短域名存储接口：接受长域名信息，返回短域名信息
短域名读取接口：接受短域名信息，返回长域名信息。
限制：

短域名长度最大为 8 个字符
采用SpringBoot，集成Swagger API文档；
JUnit编写单元测试, 使用Jacoco生成测试报告(测试报告提交截图即刻)；
映射数据存储在JVM内存即可，防止内存溢出；

题目分析：
1.应用场景：
    用户传入longURL, 返回shortURL，shortURL可能包含在文本中，或某个用户的微博等文字中
    用户传入shortURL，返回longURL，再用longURL访问原地址，这个过程会有2次调用
2.约束条件：
    吞吐量：qps从系统设计角度自然是越大越好，容量可以扩展的，后续可以考虑
    时延要求：shortURL返回longURL对于用户来说有较高的要求，因为涉及2次调用，通过缓存和数据库所在IDC就近部署可解决
    稳定性要求：稳定性要求不高多情况下，单体就可以解决，且数据全部放到本地磁盘或内存中也是OK的，但如果对稳定性要求较高。则需要对应用层无状态化
    数据保存时间：长URL和短URL短生命周期是怎么样短？根据场景，笔记类应用希望数据永久保存
    数据量大小：62^8  基本数据量超过10亿，是否要设计的这么大，需要预估用户量，考虑这部分扩展性。

方案设计：
1.主要思路
    单体方案：数据持久化生成，保存等都在一台机器上，没有分布式场景下的问题。但qps，稳定性等会有问题，追求快，则可以这样实现

    随机生成方案：longURL随机生成一个shortURL，然后去DB中看是否存在，不存在则插入，存在则重新随机生成。数据量大后生成过程变慢
        服务层：URLService encode(String longURL)  unEncode(String shortURL)
        数据库：SQL类型数据库和NoSQL数据库都可以
            SQL数据库：
                表结构：（id，short_url, long_url)   short_url上建索引
                进一步考虑：
                    qps提高？
                        缓存（本地或分布式都OK）： 增加读能力
                    数据量大了如何扩展？
                        单数据中心多区域缓存架构
                            分库：
                                扩容时机：数据量在2000万条的时候
                                hash key的选择：
                                    id：longToShort   随机生成short，查多次，看是否有重复，然后按照id插入，涉及多次调用
                                        shortToLong   先多次查获取id，然后按照id获得longURL
                                    short_url:
                                        longToShort   随机生成，查一次是否重复
                                        shortToLong   查一次数据库
                                    long_url:
                                        longToShort   随机生成short，查多个库是否有重复，没有则插入
                                        shortToLong
                                    8字符中的一个作为key  （分库不会有太多多库，62个库足够了）  推荐方式
                                        longToShort   对long进行字符加总，然后取mod 62 以这个字符作为hash key，例如获得a
                                                      生成7为对short + 刚刚的a 作为short。查重复只需要查一次库即可
                                        shortToLong   short中携带了a，也只需要查一次即可
                                部署情况：缓存多区域，例如中国区，美国区，欧洲区
                                        数据中心（数据库）放到中国区
                                存在问题：服务层直接查数据中心比较时延较高
                        多数据中心多缓存架构（解决服务层查询中心数据慢的问题）
                            8字符中的一个作为key，key可以作为分库多hash key，也可以作为划分区域的一个key
                            部署情况：每个区域单独一个数据库一套缓存

    发号器自增方案：8字符短URL可以对应一串数字long类型足够了，可以使用数据库自增ID来发号，没有随机的冲突问题。数据库自增ID在qps要求很高的情况下，会是个瓶颈
        数据库：表结构 （id， long_url)   即id就是shortURL
        存在问题：
            自增ID成为单点，且有性能瓶颈：
                snowflake方式：借鉴snowflake的思路，服务层生成ID且不同，存在时钟回拨，部分号浪费但问题
                多个发号器：每个发号器步长不同，例如3台，每次增3
                单发号器长步长：一次发100个号，服务层存储，服务层升级或挂掉号可能消失，需要权衡这个问题

