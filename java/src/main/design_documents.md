# 短域名系统设计文档

## 方案设计
短域名服务，网上方案很多并且有比较详细的说明。本文采用使用最广泛的设计方案——62进制法。基本思路是：用[a-z, A-Z, 0-9] 62个字符来实现62进制数，为每个长域名url生成唯一的一个62进制数。具体实现方式如下。

### 长域名转成短域名
1. 查询数据库，是否已经存在对应的长域名url。
2. 将长域名插入数据库，生成并返回自增id
3. 将十进制id转成62进制字符串，并返回

### 短域名转成长域名
1. 将输入的短域名字符串，按照62进制转换成10进制
2. 根据转换后的10进制结果从数据库获取对应的长域名url，并返回

### 为什么采取此种方案设计
设计简单，实现起来容易。应用广泛，资料较全，遇到问题可以快速找到解决方案。


## 系统风险及解决办法
### 长域名转成短域名接口QPS过高
长域名转短域名接口qps过高，系统瓶颈在于插入数据库操作，导致数据库压力过大，影响服务可用性。此种场景可以使用mq来达到削峰目的，即所有转换请求不直接插入数据库，而是发送给消息队列发送一个消息即返回，数据库服务器自行消费消息完成插入操作。在系统业务设计层面，可以提示用户插入完成，最迟**时间可以查询短域名连接。

### 短域名查询长域名接口QPS过高
短域名转换长域名接口QPS过高，系统瓶颈在于查询数据库操作。为避免大量请求涌向数据库，同时考虑到长域名一旦转成换短域名，结果不会改变，可以考虑把一部分长域名转换结果长期存储到本地内存中。如果本地内存有，就从本地内存直接取，如果没有再去查询数据库。此时要注意两个问题：
1. 本地内存使用大小不能无限制，将太多的数据放入本地内存，可能导致gc问题，使系统性能恶化。为此可以使用Google guava 提供的LocalCache缓存，内部实现了LRU，控制内存使用大小
2. 本地内存在冷启动问题。为防止启动期间，大量请求涌向数据库，可以采取热身，将热点数据提前写入本地内存。

采取本次内存之后，还是存在大量请求涌向数据查询的风险，主要有一下两个场景：
1. 某一个非热点数据，没有被本地缓存，突然被大量请求，此时应该用锁控制，只允许一个请求去数据库更新，其他请求等待更新结果返回。
2. 恶意攻击，接口被人大量用非法的不存在的短域名url攻击。此时可以使用 布隆过滤器，快速过滤掉不存在的短域名请求，保护系统

### 系统QPS过高
应该对每个接口进行限流操作。不同的接口使用不同的限流参数。与此用时可以添加鉴权操作，可以快速查出请求来源，并且过滤掉大量非正常请求。



## 最终架构设计
考虑到上述因素，最终方案设计如下：

![GitHub](http://dbp-resource.cdn.bcebos.com/a1620f93-4200-9024-4be8-61a6751b1340/%E4%B8%BB%E5%8D%A7.png "GitHub,Social Coding")

架构设计图如下所示：

![GitHub](http://dbp-resource.cdn.bcebos.com/a1620f93-4200-9024-4be8-61a6751b1340/%E6%AC%A1%E5%8D%A7.jpg "GitHub,Social Coding")



