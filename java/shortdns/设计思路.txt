一、接口说明：
	1、短域名获取：
	   入参：长域名
	   出参：短域名
	   
		 1.1设计思路：
		    给每个长域名分配一个唯一序列号，并定义一个62位的短域名字符词典，通过对分配的唯一序列号做一定规则计算获取字符词典下标，将下标对应字段拼接，得到短域名，这样只要唯一序列号不重复，生成的短域名也不会重复;
		    
			1.2步骤如下：
			1.2.1、定义一个62位数组DIGITS，存储0-9,a-z,A-Z共计62位数据
			1.2.2、给每一个需获取短域名的长域名分配唯一序列，不可重复。
			       使用原子类,AtomicInteger.incrementAndGet()方法来保证序列号的唯一性
			1.2.3、对这个唯一序列值进行计算，得到唯一短域名。
			       通过循环除62并取62模操作，得到不同的DIGITS数据下标，通过下标获取对应数组字符，将字符联接起来，得到唯一短域名。
			1.2.4、将生成的域名放入到JVM内存中，
		         将短域名作为KEY,长域名作为VALUE,存入到线程安全的ConCurrentHashMap中
	
	 2、长域名获取：
			入参：短域名
			出参：长域名
			
			因在短域名获取时，会将长短域名通过hashmap映射，放入到JVM内存中，所以长域名的获取只需直接将传入的短域名作为key，在JVM内存中的ConCurrentHashMap中获取即可
	


二、假设说明：
为保证程序运行环境的简单性，达到只需运行服务器具备基本的JVM环境（JDK1.8）即可运行程序，此项目目前设计为单机版，即如果重启或部署多台，会导致数据丢失或唯一序列号重复，如果做成分布式版本，需考虑两个方面：
1、唯一序列号分布式生成
   使用数据库的sequence.nextval自增序列来生成唯一序列
   使用redis的Incr并发自增器来生成唯一序列
   如果对生成的短域名无限制，也可使用雪花算法生成唯一序列

2、持入化存储
   考虑到数据的永久性，可将数据持久化到数据库中。
   考虑到数据的读取效率，可在redis中存储一份，在将短域名往数据库持久化时，往redis中也存入一份;
   考虑高并发场景下数据库性能问题，可将数据先放入到MQ队列中，再通过线程池去控制并发的个数，来保证性能;



三、程序说明：

1、开发环境：
JDK 1.8
Itellij IDEA

2、运行步骤：
1.1执行start.bat批处理（运行机器须装有JDK1.8，且配置环境变量）
1.2浏览器输入如下地址：
http://localhost:8088/swagger-ui.html
1.3选择调用方式，开始验证接口





 