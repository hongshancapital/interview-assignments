## 一、需求分析

实现短域名服务，要求

- 短域名存储接口：接受长域名信息，返回短域名信息
- 短域名读取接口：接受短域名信息，返回长域名信息

## 二、功能点分析

- 长域名转换为短域名
- 存储映射关系

## 三、思路分析

### 如何将长域名转化为短域名

- 压缩字符：实质不存在某种压缩算法，可以任意表示长字符串
- hash算法：容易存在hash碰撞
- 用某一个随机数唯一标识一个长域名，并将随机数做字符编码
- 本题设计中选择用随机数标识唯一一个长域名

### 随机数如何编码

组成短域名的字符可包括：

【a-zA-Z0-9_-】共64个字符，将随机数转换为64个字符中的某一个，实质就是将2进制转为64进制

### 如何生成唯一随机数

- 如果使用第三方工具的话，考虑到后期的扩展性和多节点伸缩部署，可使用redis自增序列

- 在本题要求中，尽量不使用第三方工具，可考虑雪花算法，但雪花算法的长度过长，可表示最大为64bit大小的整数，为一个Long型。由于题目要求最长八个字符，使用64进制对随机数进行编码，满足此条件能表示的最大整数为48bit大小的整数，故对雪花算法进行改良，去掉机房和节点限制，具体表示为：

  41bit----》精确到毫秒

  7bit----》每毫秒接收到的请求数

### 映射关系存储

- 如果使用第三方工具的情况下，可使用redis存储映射关系；

- 在本题目，数据在jvm内存中存储，可考虑使用java原生集合map类。考虑到内存溢出的风险，此处需要对map做特殊处理，增加过期策略，自定义带过期时间的map缓存集合，底层使用ConcurrentHash，使用timer定时清理过期键值对；

- 考虑本题中会大量查询长域名是否有对应的短域名，使用两个map集合存储映射关系，其key-value可表示为：

  长域名md5值---》短域名

  短域名---》长域名

### 一些tips思考

- 为防止有人知道随机数生成及编码规则后恶意刷短码的情况发生，将【a-zA-Z0-9_-】共64个字符打乱顺序；

- 实际生产中存储短域名和长域名的映射关系，是通过数据库+缓存服务器（如redis）进行存储，为防止伪造大量短码导致缓存穿透，可以增加布隆过滤器来解决该类问题，但布隆过滤器存在一定的误判风险，此时可考虑增加一定的校验措施，其目的就是过滤掉不符合要求的伪造短码，如checkSum和校验，具体思路可参照：在最长8位字符的基础上增加1位，其计算规则为：前面8位字符代表的long型数据的和与64取与

| --------id base64编码-------- | ---校验和--- |
| ----------------------------- | ------------ |
| a s d x K 9 B1                | M            |

<!--注：在本题的代码示例中，考虑到字符长度限制及能够表示的最大整数，并未增加一位做和校验-->

## 四、接口设计

参照题目要求，提供两个查询接口：

1.长域名转换为短域名查询接口；

2.通过短域名查询长域名接口；

具体接口参数可查看Swagger接口文档

## 五、系统设计

使用springboot快速搭建web服务，实际生产中可使用数据库+redis存储映射关系，用redis自增序列来充当发号器，redis采用哨兵模式，多主多从，使用布隆过滤器来避免缓存穿透等问题。同时，web服务节点支持横向扩展。具体可见系统架构图。

## 六、性能测试

使用Jmeter进行参数化压力测试，逐步增加并发量，在压测的过程中关注系统资源情况(vmstat、top、meminfo等工具)。



