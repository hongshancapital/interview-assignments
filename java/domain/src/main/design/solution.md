# 设计文档

##需求分析
- 需求理解为：给定一个字符串，返回不超过8位的字符串，并存储返回值——入参的映射关系。
- 可以考虑自然数与入参进行映射，但数据不安全；
- 参考网上对入参加密和数值映射两种方案，考虑到入参加密算法效率问题，且可能得到相同的返回值，这里采用数值进行映射。
- 1、由于数值和存储映射关系的map是公用的，这里采用JAVA并发类避免高并发造成线程不安全的情况；
- 2、避免对同样的长url进行重复映射，同时存储反映射关系
- 3、打乱进制code的顺序，并使用随机数SecureRandom，提高数据安全性；
- 4、采用64进制，一方面是提高数据安全性，另一方面是方便取模做加密；如数据量不大，并需进一步提高数据安全，可用128进制，但需额外补充特殊字符；
- 5、避免初始返回结果过短，底数初始化为1000000，加上100以内的随机数，可根据实际数据量进行调整；
- 6、主要代码逻辑在DomainReflectFacade.java中，jacoco测试主要针对DomainReflectFacade.java的方法进行测试

##假设项
- 映射数据存储在JVM内存即可，防止内存溢出；
- 没有理解此项要求的含义和具体场景，这里给出一些假设场景和解决方案，未在代码中实施
- 1、数据均为热点数据，且常用数据量很大；方案为加内存加设备
- 2、总数据量大，常用热点数据一般；可以考虑使用LRU算法，定期或将数据写到硬盘上，当内存未命中时，去硬盘查找并存到内存中
- 3、数据要求不高，实时或者定期删除部分数据，释放内存

##架构设计
- 由于要求是映射数据存在JVM内存中，所以没用考虑使用redis，若考虑容错性能，使用集群需处理数据一致性（使用mq做最终一致性等）；若考虑灾备等问题，需要考虑数据写到硬盘，由硬盘做备份；

##性能测试方案
- 给定4000(PC在5000时会提示创建native线程时内存不足)并发请求，同时进行长域名存储，统计出最长处理时间和返回的不同的短域名数量
- 在性能测试时发现返回的短域名出现重复的情况，排查代码发现，不能使用随机数对底数进行自增，改回每次自增1，查看AtomicLong源码，发现是乐观锁原理，随机数增加会造成类ABA问题；
- 单个请求时间在100毫秒左右