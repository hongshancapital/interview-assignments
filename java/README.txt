1.长域名映射短域名
    长域名的映射，类似发号系统的递增id，一个id映射映射一个长域名；进而，将10进制的id转换为由0-9a-zA-Z组成的62进制的数；
    再将映射后的62进制数，及短域名服务的url，拼接成串作为返回。
    转换过程，需要考虑的点：
    a.发号系统：发号系统要考虑递增id的唯一性、性能。
        可使用带自增主键的mysql数据库、redisson封装的redis指令、雪花算法生成等。本例只使用了简单的原子类型进行累加模拟
        唯一性：mysql数据库实现简单但是需要根据集群来设置单节点的步长来保证唯一
              根据不同的集群部署方式，会出现一致性及短暂的服务不可用问题,
              雪花算法会因为时钟回拨，出现一批id的重复，而且，雪花算法需根据节点机房编号实现，某一节点宕机，如果id位长没有留有余量，也会出现重复
        性能：雪花算法不需要依赖三方中间件，主要性能开销为网络请求开销，性能好；
            redis性能较好；
            mysql数据库因为要记录自增id，需要写操作，会涉及一些事务操作，性能相对较低；
    b.考虑转换后的短域名，是否需要与长域名做一一映射。
        如果需要做一一映射，需要将生成的长域名与短域名进行落盘存储，每次长域名请求需要查询数据库查找是否存在对应短域名，不存在再生成新的短域名进行存储
        如果不需要做一一映射，即一个长域名可以对应多个短域名，本例子没有对长域名进行落盘存储，而是将生成的短域名存入本地缓存，
        考虑到jvm的内存大小，将缓存初始容量设置为100，最大容量设置为1000，过期时间设置为1小时，并开启软引用，来保证不会因为内存不够而造成OOM错误，
        同时，缓存长域名映射时，缓存时间1小时，可尽量缓存热点域名，因为经常访问的长域名，缓存命中之后，会重置缓存时间。

2.短域名映射长域名
    如果第一步中，生成的短域名，落盘存储了，当短域名存在时，最终是会返回一个对应的长域名的，
    如果第一部中，生成的短域名，没有落盘存储，当一个生成的短域名，如果在缓存中过期了，则缓存不会命中，是否合理，需要根据业务需求决定。