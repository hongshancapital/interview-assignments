# 设计文档

## 需求解析

需求理解：
输入一个长字符串（长度不限），输出一个短字符串（长度限制为8），需要存储长字符串和短字符串的对应关系，且能根据短字符串找出其唯一对应的长字符串。

需求解析：
可将长字符串视为Value，短字符串看做key。系统需要为任意一个value生成一个key，且保存kv的对应关系，之后可以通过key值快速查询其对应的value。

## 概要设计

### 算法设计
由于key的长度受限，如采用hash算法，必然会出现hash碰撞，处理碰撞必然降低效率。
由于8位62进制（字符串可以是数字大小写字母，所以是62进制）的最大值为218340105584895L，容量足够，故可以维护一个***发号器***（自增序列），给每个请求发放一个id，同时将这个id转换成62进制，将这个62进制字符串作为key即可，这样生成key的效率将会大大提升。

### 存储设计
该场景下，为提高效率，kv并不一定需要严格的一对一关系，可以是多对一关系（即k多v一），两种不同对应关系的优缺点如下：

一对一：
- 优点：key的长度受限导致key数量受限，这种关系可以最大程度上保证系统的容量
- 缺点：需要维护一对一关系，相同的value必须返回相同的key，在空间或者时间上必然有一方要做出牺牲，且系统处理复杂度增高

多对一：
- 优点：系统复杂度降低，效率高
- 缺点：相同的value返回不同的key，会降低系统容量

拟采用***多对一***方案，提升系统性能。系统容量问题可通过其他方式解决（比如限流等）。

## 详细设计

### 内存方案（题目要求）
发号器可以使用原子类（AtomicLong）来实现，保证并发下的发号唯一性。
存储器可以使用ConcurrentHashMap（保证多线程的安全性和效率）。

### 单体式方案
可使用数据库（mysql）解决：
发号器可以使用表的自增主键即可。
存储器可以使用该表，新建一个字段存储长链接。

### 分布式方案
发号器可以使用redis实现（可以分片，每片的初始值和步长不同即可），或者zk实现（DistributedAtomicLong）。
存储器可以使用数据库。

## 压力测试

jmeter新建两个线程组（模拟转换短链接和获取长链接），分别以100线程循环20次测试TPS。转换短链接的TPS大约1300左右，获取长链接的TPS为2000（达到测试最大值，理论TPS应该更大）。


## 备注
所有截图均在img目录

