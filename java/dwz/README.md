# 短域名服务经典实现说明

## 核心思想
### 短域名的生成: 
8位短域名，如果使用Base62, 以二进制而言最多可以支持47位。以murmur3_32计算hash值, 需要占用32位。  
这里将该hash值放在最前边， 在33-43位填充hashCode取模的值以进一步降低冲突, 后4位暂时作为保留位。
### 哈希冲突:
在冲突概率不大，但是发生哈希冲突的情况下，使用*作为冗余字符串，加入长url最后方后以递归方式重新计算哈希。
### 键值对存储:
以“短域名-长域名”键值对的方式，保存在Mapper中，这里以策略模式抽象了存储逻辑。  
具体的底层逻辑提供了基于HashMap, SkipListMap, TrieMap的实现，它们都是线程安全的。  
从效率的角度来说，hashMap的读写效率都是最优的，然而由于其内部的Node数组有长度不可超过Int最大值的限制，
导致其可支持的容量不可大于2^30。不过在实际使用中，最大容量也受到物理内存的限制。  
在我本地开发机上（16G物理内存，8G空闲），经压测，不抛出OOM的安全容量大约在2^26。
### 清理策略
为减少内存的使用，我设计了ExpireMap的结构，可定期清理长期没有跳转请求的键值对。默认的一个策略是，在每次get
时，将过期时间设置为当前时间+ttl间隔。同时后台启动一个定期任务去检查那些键值对，清除当前时间>过期时间的。

## 接口说明
### 根据长域名生成短域名

url: POST /urlToShort
步骤: 首先进行URL的一些处理（中文转码，没有协议的加上http://默认协议等），然后基于murmur3_32生成短域名，
存储在mapper本地内存。

### 根据短域名跳转长域名

url: GET /{shortUrl}

步骤: 从mapper本地内存查找键值对，更新过期时间。

# 性能测试
### mapper对2^20（大约百万+）做put, get性能测试
```
StopWatch 'mapper写性能测试': running time = 2549904900 ns
---------------------------------------------
ns         %     Task name
---------------------------------------------
459887500  018%  trieMap: put测试
254513400  010%  hashMap: put测试
1835504000  072%  skipListMap: put测试

StopWatch 'mapper读性能测试': running time = 2325863300 ns
---------------------------------------------
ns         %     Task name
---------------------------------------------
369543300  016%  trieMap: get测试
176292500  008%  hashMap: get测试
1780027500  077%  skipListMap: get测试
```
### service性能测试 (分别使用1000条域名数据或50条真实历史浏览数据)

```
StopWatch 'service性能测试': running time = 15907700 ns
---------------------------------------------
ns         %     Task name
---------------------------------------------
014730300  093%  写测试: 域名Only 1000
000212400  001%  写测试: 真实浏览记录 50
000926300  006%  读测试: 域名Only 1000
000038700  000%  读测试: 真实浏览记录 50

```