# 短码设计
##本程序实现的目标：
 简单的单点生成短码的功能；
 最重要的是代码规范和文档规范，稳定性，健壮性。

##需求分析
撰写两个 API 接口:
- 短域名存储接口：接受长域名信息，返回短域名信息
- 短域名读取接口：接受短域名信息，返回长域名信息。

限制：
- 短域名长度最大为 8 个字符，理解为，去掉域名后的短码长度不超过 8 个字符。（即 https://t.cn/xxx，xxx 的长度不超过8个字符)
- 采用SpringBoot，集成Swagger API文档；
- JUnit编写单元测试, 使用Jacoco生成测试报告(测试报告提交截图即刻)；
- 映射数据存储在JVM内存即可，防止内存溢出；


## 设计思路
###程序架构设计
- 考虑到服务的通用性和易用性，这两个接口，采用restfull方式对外提供服务；
- 程序采用 spring boot 项目架构；
- 项目采用 Maven 需要引入的依赖有：Swagger、JUnit、Lombak、log4j2
- 为了便于调试，增加日志记录，采用Slf4j，其实现使用log4j2
- 虽然使用 Lombak 提供的注解，降低了部分可读性，但是其学习成本比较低，且容易辨识和理解，主要是代码更加整洁，突出主要业务逻辑，所以程序使用了此包

###算法设计

- 短码算法与结构：由[a - z, A - Z, 0 - 9]这62个字母与数字组成，长度最大为8位，可以生成出62^8个短链接
  - 通过自增id生成,缺点是短码有序容易被破解，优点是实现简单且不会出现重复
  - 通过摘要算法，缺点是实现稍微复杂一点且小几率存在碰撞的可能性，解决冲突会比较麻烦，优点是破解起来相对自增id会麻烦点
  - 普通随机数，缺点是碰撞的可能性比较多，感觉没有优点
- 本人选用第一种算法，因为实现简单且不会出现重复。数据都存在内存中，内存容量有限，当内存容量达到上线会淘汰掉一部分数据      
- 防止内存溢出：采用JVM内存存储，可配置短域名个数的最大容量（在程序中配置），当容量超过后，剔除生成最早的，最近不常用的。
- 短码长度控制：默认长度从5位（可以根据需要配置）开始，当超过8位的话，自动从5位最小值开始，淘汰旧的。

###程序结构设计
 短域名存储接口流程： 
-【用户】{访问获取短域名存储服务}
- 服务器【控制层】{参数校验，不通过，直接返回错误提示，校验通过，进入调用服务类，获取短域名}
- 服务器【服务层】{调用DAO层，查询是否存在此长域名对应短域名，如果存在，则直接返回短域名；如果不存在，则调用短域名生成器，然后保存短域名；最后返回短域名}
 
 域名读取接口：
-【用户】{访问短域名存储服务}
-服务器【控制层】{参数校验，不通过，则返回错误提示，校验通过，调用服务层}
-服务器【服务层】{调用DAO层，查询对应的长域名，如果存在则直接返回长域名；如果错误，则返回错误null}

系统配置：考虑到程序的扩展性，做如下配置
- 短域名配置
配置文件： shorturl\src\main\resources\config\application.properties
spring.profiles.active=dev
指定测试环境，端口 8082
- 容量配置 ShortCodeStorage.java 类 CACHE_MAX_SIZE

###单元测试
- 生成和编写单元测试类，进行单元测试
- 使用Jacoco生成测试报告

###系统性能测试方案
系统性能测试方案：
可以选用 Apache JMeter 、 LoadRunner 等测试工具进行测试。
主要测试指标有：
- 并发生成短域名性能：
   - 响应速度，最大并发量
   - 是否出现重复短域名
   - 字符长度超过8位后，是否处理
- 内存溢出测试
   - 超过最大内存容量，能否继续生成，如果能够继续生成
   - 根据淘汰算法，已被淘汰的长域名重新请求应该生成新的短域名
   - 根据淘汰算法，超容后，最近访问过的不会被优先淘汰
- 并发请求获取长域名
   - 响应速度，最大并发量
   - 获取不存在的域名的异常处理
 
本次只是使用JMeter做了一次简单并发测试，测试结果

###Api接口
http://localhost:8082/swagger-ui.html#/

- 短域名存储接口： /api/short/short
  - 请求方式：Post
  - 请求参数：longURL
  - 返回格式: Json 
  - 返回值： 
        {
           "success": true,
           "message": "http://t.com/wqqqqq"
         } 
- 短域名读取接口:  /api/short/long
  - 请求方式：Post
  - 请求参数：longURL
  - 返回格式: Json 
  - 返回值： 
         没有找到的时候：
         {
           "success": false,
           "message": "没有找到对应的长域名"
         }
         找到的时候：
         {
           "success": true,
           "message": "http://www.demo.com/xx"
         }
         

###功能扩展设计
- 增加重定向接口: 访问短域名，自动重定向到长域名
- 当需要将数据存储，存到数据库的时候，需要实现 ShortDaoImpl 类，并在相关地方进行修改。


###扩展性设计（性能与安全）
- 热点频繁访问的长域名，可以增加缓存，减少数据库查询。
- 可以根据需要增加相应字段，比如生成时间，失效时间、续期
- 对于接口的安全性，可以接入权限认证服务，增加权限校验。
- 算法优化：根据需求可以进行算法的优化和改进。
- 增加防攻击措施：比如同一个ip短时间内频发访问一个接口，可以拦截，不处理；


##扩展实现（针对大数据量、高并发的改进）
- 对于并发，可以使用nginx进行负载均衡，此服务部署在多套服务器上；
- 短码长码关系表可以根据短码后缀进行分库分表存储；也可以使hbase存储到hfile中；也可以使用elassitcSearch进行存储分析；
- 对于大数据量去重，可以使用BloomFilter进行命中查询；
