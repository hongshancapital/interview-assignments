# 短域名服务Doc

## 关于需求的理解

需求中描述为短域名服务，并自行搜索细节，具体实现为两个API接口

基于我的个人理解和搜索结果，这个短域名服务应该是短网址服务，即将很长的不便于记录的URL，映射到一个很短的URL上，例如：

常规URL：https://github.com/scdt-china/interview-assignments/tree/master/java

可以映射到一个短网址：http://sdns-domain/exzN1 (其中sdns-domain为短网址服务提供商的域名)

这样客户访问这个短网址时，由短网址服务返回302重定向，将客户端重定向到常规URL地址上

## 需求的实现思路

基于上述对需求的理解，整个短网址的核心在于将原始URL映射到一个随机短字符串上，我的实现中将随机短字符串的长度限定为8位(基于长度和容量的兼容考虑)，每位字符限定位“a-z”、“A-Z”、“0-9”、“-”和“_”，共64个字符，总共8位的字符串长度可以容纳64^8个地址，及28亿亿个。

8位字符串的生成，有两个思路：

摘要法：根据源地址生成8位摘要，此办法会产生哈希碰撞问题，解决办法为：如果碰撞可以向下顺延直到未使用过为止，但是地址数量变多之后，会有性能问题；

顺序数法：相当于一个8位长度的64进制数值，按顺序往后取，性能较好，也不会碰撞，但是也有个问题，就是产生的短地址是一个有顺序的地址，用户甚至可以预测下一个地址会是什么。此问题也有解决办法：对原始64个字符进行洗牌，打乱顺序，并对增量改为随机数步长向下获取。

本方案实现采用顺序数法，并且打乱了64个字符的顺序，但是为了测试方便和问题的可复现，采用了固定1的步长。

本方案主要实现将原始URL映射到8为字符串，未添加短服务域名等逻辑。

## 关键类及方法说明

ShortUrlController：controller层，定义/save和/find两个HTTP服务

ShortUrlService：service层，实现保存长URL和查询短URL的具体逻辑

LRUUrlPairsRepository：基于LRU算法实现的长短地址对的存储仓库，目前存储于内存之中，未来扩展可将Repository抽象化，并开发不同的Repository的实现，比如固定容量仓库，基于redis的仓库等；本实现基于线程安全和性能优化的考虑，再存储长短URL对时会返回最准确的短URL，而不是以上送的短URL为准：A、B俩个线程同时存储长地址，同时去检查仓库中是否已经保存长地址，为保证性能，此查询未加锁，所以可能同时查到未保存的结果，然后又各自获取短地址去保存，而保存是线程安全的操作，若A先保存，则B保存时会返回A已经保存的短URL，此时B线程需要以Repository返回的短URL为准，此策略会再高并发时浪费一些短地址

ShortUrlGenerator：短URL生成器，基础字符数组中保存了乱序的64个字符，内置AtomicLong型游标，每次向后获取1个数，然后根据每6位与63的按位与操作生成基础字符数组中的序数，按序数生成短URL

CacheNode：双向链表节点，用于实现LRU算法，此类包装长短URL对，在Repository中形成双向链表，通过链表的操作，来记录最近使用的节点

UrlPair：长短URL对

BeanConfig：Bean配置类，目前用于按参数配置，注入Repository实例

