## 设计思路

### 目标

1. 将用户输入的长域名转换为短域名，并存储映射关系
2. 根据用户输入的短域名，返回对应的长域名

### 要求

1. 支持高并发读写，并控制接口响应时延
2. 清理过期数据
3. 保证短域名的唯一性
4. 数据存储在内存中，需防止内存溢出，提供内存不足时的解决方案

### 设计思路&方案选择

#### 短域名生成方案

对生成的短域名，有两个约束：长度和唯一性。生成的短域名必须是全局唯一的，长度限制在8个字符。经过调研，可将主流短域名生成方案划分为以下几类：

1. **基于数据库、中间件等生成唯一id**：利用mysql、redis、zookeeper等工具的原子性或顺序性，可生成自增id，在将id值转换为62进制的字符串（26大写字母+26小写字母+10数字）后，保存短域名和长域名的映射关系，并将短域名返回。8个字符，理论上可存储218万亿数据。缺点是，生成id是顺序的，容易被人趴取，且当写请求量很大时，压力会给到中间件或存储。
2. **UUID**：能保证唯一性及随机性，但长度过长。
3. **snowflake等分布式id生成算法**：将64bit拆分成多个部分，分别存储机房、机器、时间戳等信息，能保证分布式环境下，生成id的唯一性，以及时间顺序性。缺点是，依赖各机器节点的时间生成id，如果机器时间回退，会产生重复id。
4. **使用hash算法**：使用MurmurHash之类的hash算法，对长域名进行hash操作。缺点是可能会产生hash碰撞生成相同的hash值。
5. **基于单机内存原子性生成唯一id**：在单机内存上维护一个id生成器，通过CAS等方式获取唯一的id，其余操作与方案1一致。缺点是，仅支持单机部署，且内存数据重启后变丢失，因此为保证唯一性，id生成不能采用类似自增id这种策略。

由于映射关系存储在内存中，所以本系统应是单机部署，分布式算法的优势体现不出来，且会降低性能，因此最终采用方案5作为短域名生成方案，采用时间戳+自增id方式生成唯一id，其中自增id使用AtomicLong实现，保证线程安全。

#### 映射保存方案

当前有多种主流的K-V本地缓存方案，例如LoadingCache，Caffeine，Encache等，他们提供了诸多开箱即用的策略，但本系统仍选择ConcurrentHashMap作为存储，原因如下：

1. ConcurrentHashMap本身线程安全

2. 与其它工具相比，ConcurrentHashMap实现原理简单源码易读，使用时，整体流程可控，方便进行debug

3. JDK8以后，ConcurrentHashMap进行了优化，加锁粒度为entry数组中的每个元素，理论上支持的最大并发量为entry数组长度，且会随着数据的增长，不断增大，能满足高并发的要求。
4. 支持定制化内存清理和内存淘汰策略，第三方工具类虽然提供了一些策略，但如果该策略不符合自身需要，进行改造会较为困难，使用ConcurrentHashMap，由开发人员完成各类策略的开发，可实现定制化的需求。

在ConcurrentHashMap内，key为短域名，value为长域名

且为保存数据过期的先后关系，使用单向链表按时间顺序存储所有的key值及其TTL。

#### 内存清理方案

基于内存的存储件有三种主流内存清理方案：定时清理、定期清理、惰性删除。权衡性能、准确性后，采用定期清理，启用一个线程定期清理数据。

思考了两种清理内存过期数据的方案：

1. 从前向后遍历存储了key的单向链表，删除过期数据
2. 采用类似kafka清理日志的策略，维护“时间-数据”的稀疏索引，加快删除速度

由于数据全存储在内存中，内存资源较宝贵，因此采用方案1，用时间换空间

#### 防趴取方案

由于唯一id是基于时间戳+自增id的方式生成的，可能会被他人趴取，因此需在编码过程中添加一串随机字符串，且该字符串会定时更换

####  内存不足的时机

考虑到长域名长度可变，所占内存可大可小，因此无法仅通过限制数量来防止内存溢出：如果设置大了，当请求转换的域名均很长时，会导致内存溢出，如设置小了，能保证内存不溢出，但当转换的域名均很短时，会浪费许多内存资源。

本项目的方案是启用一个线程定期检查当前内存是否足够，检查标准为：

1. 当前存储数据超过系统限制时
2. JVM内存可用内存不足某个阈值时

以上任一情况发生，都将认定内存不足，将标志位置为false，拒绝其它写请求，在保证不产生内存溢出的前提上，尽可能存储更多的域名，

#### 内存不足方案

当域名写请求量过大，导致数据存储超过阈值时，可采取的策略有：

1. 直接拒绝写请求，保证已存储数据在有效期内仍可以访问
2. 按过期时间先后顺序，根据TTL、LRU等策略，淘汰部分数据，保证能接纳新的写请求

个人认为一旦向用户返回写请求成功，就应保证其域名在有效期内的可用性，而不能直接删除，引其客户的困惑。因此最终采用方案1

#### 长域名重复

用户可能会使用重复的长域名多次调用转换服务，此时需要返回相同短域名吗？

个人认为不需要，原因如下：

1. 如返回相同短域名，则需多使用一倍的内存，来保存长域名至短域名的映射，代价过大
2. 用户可能确实有返回不同短域名的实际需要，可通过计费的方式杜绝用户恶意转换，多次调用服务的情况

#### 输入限制

需对用户上送的字符串长度进行限制，否则，如有用户恶意上送超大长度的字符串，内存将被轻易的打满，无法接收其它请求

#### 处理伪共享问题

系统内部有多处使用了volatile类型的共享变量（id生成，判断内存是否足够等），需向该变量的前和后各填充部分字节，以保证不会出现伪共享的问题，影响其它共享变量的读写效率

#### 测试方案

1. 测试系统TPS：使用jmeter对系统进行压测，得到两个服务接口的TPS以及平均响应时长
2. 测试返回值正确性：使用测试类，先使用长域名调用域名转换服务，获得其短域名，随后用短域名调用读短域名接口，获取其长域名，将接口返回的长域名与最初的长域名进行比对，查看是否正确。
3. 测试生成短链接唯一性
4. 验证数据清理工作是否如期执行
5. 验证是否能检测出内存不足的异常情况，以及在内存不足时，是否能拒绝后续的域名转换请求

### 测试结果

1. 测试基准：

   用于压测的机器为笔记本电脑，参数为

   CPU:intel i7-6700HQ

   内存：16G

   考虑到硬件平台的差异性，无法通过具体的参数值，来比对各系统的优劣。因此，我写了一个接口，该接口不进行任何逻辑处理，直接返回固定字符串。先对该接口进行压测，作为后续压测结果的参考对象。参考值如下：

   | 线程数 | 样本数 | TPS  | 响应时长平均值 | 响应时长95线 | 响应时长99线 |
   | ------ | ------ | ---- | -------------- | ------------ | ------------ |
   | 200    | 100万  | 4654 | 42             | 81           | 119          |

2. 长域名转换接口压测：

   数据量：500万条字符长度为200的长域名

   结果：

   | 线程数 | 样本数 | TPS  | 响应时长平均值 | 响应时长95线 | 响应时长99线 |
   | ------ | ------ | ---- | -------------- | ------------ | ------------ |
   | 50     | 500万  | 4256 | 11             | 15           | 32           |
   | 100    | 500万  | 4170 | 23             | 39           | 59           |
   | 200    | 500万  | 3973 | 47             | 78           | 113          |

   可见，当200线程时，TPS以及接口响应时长等指标虽有所下降，但距离系统参考值相差不远。

   详细截图已放入doc目录下

3. 查询短域名接口压测：

   数据量：100万样本数

   结果：

   | 线程数 | 样本数 | TPS  | 响应时长平均值 | 响应时长95线 | 响应时长99线 |
   | ------ | ------ | ---- | -------------- | ------------ | ------------ |
   | 50     | 100万  | 4873 | 10             | 26           | 35           |
   | 100    | 100万  | 4694 | 20             | 43           | 67           |
   | 200    | 100万  | 4618 | 42             | 82           | 121          |

4. 测试域名唯一性与正确性：500万条数据写压测完成后，将系统内ConcurrentHashMap的大小进行打印，发现等于500万，说明生成的短域名唯一，未发生冲突。随机选取部分生成的短域名，调用获取长域名接口，数据返回正确。

5. 验证数据过期清理：将application.properties文件中的域名失效时间调整为10秒，将长域名转换为短域名后，用短域名查询对应长域名，10秒内能获取到正确域名，10秒后返回无域名信息，验证通过。

6. 验证内存不足时的策略：

   * jvm内存不足：

     前提：将jvm剩余空间下限调至与堆空间总大小相近

     步骤：域名转换服务压测500万条数据，压测至一半，提示存储空间不足。

   * 存储域名超出限制数量：

     前提：将短域名失效时间调整为1分钟，映射关系存储上限设置为10条。

     步骤：在1分钟内请求11次域名转换服务，前10次成功，第11次提示存储空间不足。待1分钟，有过期数据被清除后，再次请求域名转换服务，请求成功。

### 其它

   * 可根据硬件具体情况，调整JVM启动参数，以及application.properties中的各项属性

   * 模块设计图、压测截图、单测截图等详细信息已放入doc目录下

### 联系方式

李偲 942748117@qq.com