### 1、需求

#### 实现短域名服务

撰写两个 API 接口:

- 短域名存储接口：接受长域名信息，返回短域名信息
- 短域名读取接口：接受短域名信息，返回长域名信息。

限制：

- 短域名长度最大为 8 个字符
- 采用SpringBoot，集成Swagger API文档；
- JUnit编写单元测试, 使用Jacoco生成测试报告(测试报告提交截图即刻)；
- 映射数据存储在JVM内存即可，防止内存溢出；

### 2、设计思路

#### 2.1 架构图

![架构图](E:\spring-boot\shortdomain\架构图.jpg)

#### 2.2 生成短域名

​        短域名由数字、大小写字母组成，长度不超过8。先设置好数字、大小写字母的char数组，数字长度是62，再生成随机数，以62取模，取模结果为0至61，以此数字为char数组下标，从char数组中取值，共取8次生成随机字符串做为短域名。

#### 2.3 短域名存储

​       使用ConcurrentHashMap做为底层存储构建本地KEY-VALUE缓存，value是内部类，包括时效时间和存储的域名。本地缓存能设置存储的最大内存值和已使用的内存值，缓存不能超过最大内存值，防止出现OOM。每次存储KEY时都先计算本次存储占用的内存加上已使用的内存，如果超过最大内存，则触发删除过期KEY的操作，如果还没有足够的空间存储，则删除最近未使用KEY。增加、删除缓存中的KEY时都要更新已使用的内存值。使用LinkedList存储最近使用的KEY，每次获取KEY的结果时，如果KEY存在且未过期，则将KEY放入表头。表尾代表的是最近未使用的KEY。

#### 2.4 本地缓存KEY的淘汰策略

##### 2.4.1 获取缓存时进行过期淘汰

​       获取缓存时，先从VALUE里取出KEY过期时间，如果KEY过期时间，小于当前时间，则将KEY清除，返回null，否则返回结果。

##### 2.4.2 定期淘汰KEY

​       定期执行淘汰KEY的线程，为了保证本地缓存的性能，不扫描整个缓存进行过期KEY淘汰。而是每次取出20个KEY进行过期淘汰，如果淘汰率超过75%，则再取出20个KEY进行淘汰，知道淘汰率低过75%。

#### 2.5 长短域名存储

​        通过构建的本地缓存创建两个缓存（也可以使用一个缓存，两个缓存方便统计长域名、短域名的数量），一个缓存以短域名为KEY，长域名为VALUE，一个缓存以长域名为KEY，短域名为VALUE。生成短域时，两个域名都要存储数据方便查询。

#### 2.6 API设计

​		构建短域名存储的HTPP接口，参数中传入长域名，如果缓存中没有则创建短域名，并进行缓存，如果缓存中有数据，从缓存中获取数据，返回短域名。

​         构建短域名读取的HTPP接口，参数中传入短域名，如果缓存中有数据，从缓存中获取数据，否则返回null。

