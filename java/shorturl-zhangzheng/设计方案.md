### 方案设计
核心目标：
- 短url生成本质上是实现了一个映射函数 f: X -> Y,来建立长url与短url的一一对应关系
- 这个映射函数满足：如果 x1 != x2, 则 f (x1) != f(x2);对于每一个 y, 能够找到唯一的一个 x 使得 f(x) = y;
- 生成的短url地址空间足够大，无重复，唯一性

实现思路
- 通过发号策略，给提交的长url的顺序，发一个十进制的编号，编号自增，可以一直增加，而且唯一对应长url,能对应的长url空间足够大
- [0~9][a~z][A~Z]可以作为组成短url结果的字符集，一共62个字符
- 问题转化为将十进制的编号映射为包含大小写的字符串
- 可以将62个字符视为一个62进制的数字表达方式
- 最终的处理方案就是将对应长url的十进制自增编号，转化为对应的62进制数字，这个62进制的字符串加上服务的域名就是最终的短url结果；8个字符的62进制数，地址空间超过万亿，足够使用
- 实现思路的关键点是十进制发号器，系统并发量主要看发号器的能力
- 小型应用可以使用数据库自带的自增主键，大并发高可用，需要用分布式发号器
- 在多节点横向扩展服务中可以考虑发号器分段，比如2个发号器，一个发奇数一个发偶数；比如10个发号器，每10个数为一个步长，以此类推

实现方案
- 提交的作业中使用twitter的雪花算法作为发号器，使用H2内存数据库保存长短URL对应关系
0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 
- 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0
- 41位时间戳(毫秒级) 一般来说这个时间能够使用69年.
- 10位的数据机器位，可以部署在1024个节点
- 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号
- 加起来刚好64位，为一个Long型
- 为了保证结果最长位8位字符，作业中对雪花算法长度进行了压缩，10位数据机器位改为2位，12位序列改为4位，整体发号结果为48位，转化为十进制也超过万亿足够实际使用
- 使用了H2内存数据库作为保存长短url结果的中间件，实际应用中应该会用到数据库+缓存的方式对转化结果进行保存；

生成短url主要流程
1. 向系统提交长url转化申请；
2. 查询该长url是否已经生成过短url；如果已经生成过，则直接返回结果；如果没有，则进入步骤3
3. 从发号器获取一个编号对应到当前的长url；
4. 将这个编号转换为62进制数；
5. 将转换后的62进制数和对应的长url入库保存;
6. 将转换后的62进制数加上服务域名作为结果返回;

还原为长url主要流程
1. 向系统提交短url还原申请;
2. 系统查询该短url对应的长url地址;如果存在则返回结果，如果不存在则返回null或提示说明

如何保证同一个长url都对应到同一个短url？
- 同一个长url可以重复多次提交，可以每次生成不同的短url对应到同一个长url，但这样做会浪费地址空间，也会浪费存储空间，最好的方式是同一个长url对应唯一一个短url
- 在长url提交后查询是否生成过短url，可以使用缓存保存生成过的长短url对应关系，减少数据库查询次数提高性能
- 在实际应用系统中，缓存的方式可以提高系统性能，但对于海量长短url对应关系缓存空间的使用也是非常庞大的，把所有对应关系全部存到缓存里也不现实，解决这个问题可以有一些折中方案
  1. 使用缓存替换策略，比如LRU，LFU等等，只在缓存中保存最近提交过的长url，设置缓存过期时间，比如1小时，1天，当同一个url再次提交时更行过期时间
  2. 使用布隆过滤器，在长URL提交上来后，现在布隆过滤器里查看是否有存在记录，如果存在，在查询缓存和数据库返回已有的生成结果；如果不存在则生成，并把结果加入布隆过滤器
- 因为使用布隆过滤器需要引入外部redis组件，为了保持作业可以直接运行使用，就没有使用缓存也没有使用布隆过滤器，是直接查询H2内存数据库判断是否已经生成过短url，在实际生产系统中可以考虑使用这些组件
