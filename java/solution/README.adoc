= 短链接方案

使用工具为
image:https://img.shields.io/badge/vert.x-4.0.3-purple.svg[link="https://vertx.io"]

== 编译

To launch your tests:
```
./gradlew clean test
```

To package your application:
```
./gradlew clean assemble
```

To run your application:
```
./gradlew clean run
```

== 思路
. 因为只有 8 字长，所以总共 62 的 8 次方总共 218340105584896 种可能，可以认为是 8 位 62 进制数
. 有保存直接查历史，存过就取出当时的编号，没存过就编号自增，保存，根据编号生成短连接
. 有查询，根据短连接生成编号，根据编号取出长链接
. 测试已经全覆盖
. 假设链接已经做URL处理过，没有非法字符前后也没空格

== 扩展
. 因为长链接也没多长，存储总量不会很大，redis会持久化，可以存储得下
. 性能：代码没刻意做性能优化，我的小破电脑每秒接近30W的rps，每天可以响应259亿次读取，部署到您的服务器上，咋都有千亿响应能力应该够用吧，不够您喊我单聊。想扩展可以把redis做集群，内存搞大，减少磁盘io，也可以前端引流读写分离，或者再分离把长链接取哈兮进行分区。。。

== 性能
```
$ java -jar build/libs/url-1.0.0-SNAPSHOT-all.jar --conf config.json --instance 16

$ curl -X PUT -d 'http://hello.world/this-is-a-full-url-111' http://localhost:8080/save
aaaaaaab⏎

$ wrk -c 1000 -t 20 -d 30 http://localhost:8080/aaaaaaab
Running 30s test @ http://localhost:8080/aaaaaaab
  20 threads and 1000 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency     3.92ms    4.19ms 118.23ms   90.38%
    Req/Sec    14.78k     3.52k   38.52k    70.10%
  8831861 requests in 30.09s, 640.13MB read
Requests/sec: 293505.36
Transfer/sec:     21.27MB

```
