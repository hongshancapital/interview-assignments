# 短域名服务设计文档

## 需求描述

- 长链接转换： 输入长链接，返回短链接
- 短链接转换： 输入短链接，返回长链接
- 短链接最大长度为8
- 映射数据可以存在JVM，但需要放置内存溢出

## 设计思路

长链接通过某种算法转换成最大长度为8的短链接，服务保存短链接与长链接映射关系。比较通用的方法有以下n中：自增id算法、摘要算法、随机数等。在根据产生出的结果计算出 [a-zA-Z0-9]的字符数组，转换成短链接，62^8≈218万亿种数据。

- 自增id

  - 可以使用mysql自增、雪花算法、redis 的 inrc等
  - 优点是不会重复，逻辑简单
  - 需要依赖第三方id生成器，自增id暴率在外，有很大的安全风险，造成链接信息泄露；不支持长链接重复查询。

- 摘要算法

  - 目前业界普遍采用的短链算法，因为MD5 可以针对任何文本生成一个唯一的特征码，同时碰撞的概率很低，两个不同的文本有可能但是几率很小会生成同样的特征码。

    > 1. 将长网址 md5 生成 32 位签名串,分为 4 段, 每段 8 个字节；
    > 2. 对这四段循环处理, 取 8 个字节, 将他看成 16 进制串与 0x3fffffff(30 位 1)与操作, 即超过 30 位的忽略处理；
    > 3. 这 30 位分成 6 段, 每 5 位的数字作为字母表的索引取得特定字符, 依次进行获得 6 位字符串；
    > 4. 总的 md5 串可以获得 4 个 6 位串；取里面的任意一个就可作为这个长 url 的短 url 地址；

  - 优点：生成简单；因为一个文本只有一个对应的MD5码，所以支持长链重复查询

  - 缺点：因为是有损压缩算法，无限的可能对应到有限的字符，不可避免会有重复。重复的概率虽然低，但是在大数据量面前就是必然会发生。（之前流量系统的短链算法因为MD5碰撞的问题，需要做额外的程序处理）

- 随机数字

  - 流程：生成一个0-218万亿之间的随机数，看这个随机数是否已经被使用过，如果是则再次生成。
  - 优点：不会重复，短URL完全随机。
  - 缺点：需要判断所生成ID是否有被使用过，这一过程可能损耗性能。

本次需求使用的是随机数字的方案，将映射关系存储在内嵌数据库SQLITE中，我们可以利用数据库主键的优势，快速查出是否被使用过和防止不同的长链接对应相同的短链接。

## 服务架构

单机部署，在服务内使用到了锁、布隆过滤器、LRU缓存等技术，若后续需要搭建分布式服务，可以将这些技术更换为相对应的中间件来支持。

## 存储结构

### 持久化层

使用到了嵌入式关系型数据库SQLITE。

- 优势
  - 使用硬盘空间，使用简单，我们导入一个jar包即可。降低JVM堆内存使用，能支持存储更多对应关系
  - SQL与MYSQL基本一致，学习成本低。
  - 持久化，长短连接对应关系不会因重启项目而丢失。

- 缺点
  - 在高并发情况下容易锁库，在有的业务中，干脆就是单线程。
  - 每次新增长URL时，需要查库，性能折损。

考虑到短域名服务的使用场景应该是写少读多，所以在写性能方面做了让步，以保证我们服务更加健壮，表结构如下:

| 字段          | 类型          | 索引类型 | 备注                               |
| ------------- | ------------- | -------- | ---------------------------------- |
| short_url_id  | char(8)       | PK       | 随机ID                             |
| long_url_hash | int(11)       | Index    | hash(long_url),查询效率比varchar快 |
| long_url      | varchar(1024) | 无       | 长链接本身                         |



### 缓存

使用到了两个淘汰策略为LRU的缓存，分别为**有效短链接cache**和**无效短链接cache**

- 有效短链接cache：在新加长链接时插入和更新是插入，默认size为1000，可以通过配置文件<u>valid.cache.size</u>配置
- 无效短链接cache：即使使用到了布隆过滤器，但是也不能避免所有的无效短URL都被拦截。为了防止这些“漏网之鱼”多次查表，所以增加了该缓存。、

## 具体实现

- 整体架构

- 获取短链接流程

  ![image-20220423225636383](.\img\单元测试\image-20220423225636383.png)

- 获取长链接流程

  ![image-20220423231417378](.\img\单元测试\image-20220423231417378.png)

# 单元测试

> Junit 执行截图

![code](.\img\单元测试\code.jpg)

> Jacoco单元测试覆盖率截图(行覆盖率和分支覆盖率85%+)

![cover](.\img\单元测试\cover.jpg)

> 注：在分支覆盖这里耍了一点“小聪明”，在项目中有考虑到有自动生成ID冲突和高并发情况下锁库的情况，这些在单元测试中并不是很好复现，因此为了提高分支覆盖率占比，在执行测试代码时，将这两种情况的代码做了注释。

# [点击这里](./性能测试.md)查看性能测试详情

# 总结

> 在功能实现方面，我另辟蹊径，使用嵌入式sqlite想存储更多的数据，想着损失一些性能来支持服务重启数据不丢失，实现之后发现，在加过本地缓存之后性能表现也不错。
>
> 通过本次小作业，收获颇丰。在工作期间，很多东西前人已经实现过了，自己并未从0到1搭建过，对高并发开发也有了更深入的了解。对部分知识停仅留在理论。同时也很少写单元测试。了解到了Jacoco工具，像是发现了新大陆，太好用了，意识到了单元测试的重要性。
>
> 最后，如果本次作业有幸通过，还请面试官通过下边方式联系我哈~，非常期待能够加入红杉。

## 联系

- Name: 王鹏昊
- TEL: 15639527187
- VX: ymxsg_wph
- email: 321626285@qq.com
- 简历：[武汉_王鹏昊__Java.pdf](./武汉_王鹏昊_Java.pdf)

