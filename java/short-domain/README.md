# 短域名服务方案设计

实现一个服务，提供长域名可以生成对应的短域名，用短域名可以获取（访问）原长域名。比如在 [https://tinyurl.com/app](https://tinyurl.com/app) 上 https://www.baidu.com 可以生成一个对应的短域名 https://tinyurl.com/yw37vz79。  
其根本就是实现一个长域名和短域名的对应关系，关键在以下两点：

- 长域名数量庞大，且长度不一，而短域名长度较小，生成的短域名不能重复
- 相同的长域名是否能生成多个短域名

## 生成短域名方案
方案主要分两类：进制转换和Hash

#### 进制转换 - 自增ID
原理是通过自增ID转换成62进制后，作为短域名的一部分。例如：
- 10进制的 ```1000``` 转换成 62进制后是 ```g8```
- 10进制的 ```99999``` 转换成 62进制后是 ```q0T```

ID连续自增，不会重复，转换成62进制也不会重复，同时进制转换后长度变小。

当有长域名需要转换时，ID发号器分配一个ID，通过进制转换生成对应的62位编码，和当前长域名对应。因为ID自增不重复，则生成的短域名也不会重复。  
又题目要求最大长度为8，而最大8位的62进制对应的ID范围是```1~56800235583```，可以对应500多亿个长域名，够用了。

对于相同长域名，生成同样的短域名，避免短域名被消耗。

生成短域名流程图
![](https://github.com/niklai-star/images/blob/main/img1/hash_flow_1.png)

生成的短域名编码和长域名的对应关系分别放在两个HashMap里：

- 一个Map保存短域名编码 - 长域名的对应关系，通过短域名获取长域名时先从缓存map里查找。
- 一个Map保存长域名与短域名编码的关系，当有相同长域名生成短域名时可以从缓存中直接查询获取历史生成的短域名对应编码。

![](https://github.com/niklai-star/images/blob/main/img1/hash_flow_2.png)

代码中类图关系如下：  
![](https://github.com/niklai-star/images/blob/main/img1/hash_class_1.png)

在当前代码里自增ID通过在同步锁下对long型正整数从1开始自增操作实现。

因为自增ID是规律的，所以转换成62进制的编码也是规律的，根据规律可以遍历获取所有短域名。可以通过以下几种方法规避：

- 在```1~56800235583```范围内随机挑选ID生成62进制编码。因为随机挑选，无规律，所以生成的短域名也没有规律

  但是多次随机挑选后会挑选到曾经使用过的ID，所以需要再维护一个已使用ID的Set，每次挑选后在缓存的Set里查找一下是否使用，如果使用过就再次随机挑选。这在大批量长时间使用的情况下可能会对性能有影响。

- 将自增ID按段分片，例如```1~10000```、```10001~20000```等分成多段，长域名经过Hash运算后分配到对应段上生成自增ID，一定程度上生成的短域名基本没有规律。

  分段越多，产生规律的可能性越小，但是维护这些分段的工作量就越大。

生产环境中自增ID可以使用Redis或者数据库自增字段的方式产生。

#### 进制转换 - Hashids（当前代码采用的默认方案）

Hashids开源组件可以实现将一串数字转换成多位随机编码，同时也不会出现在连续数字的情况下产生规律的编码的问题，很好的解决了上述方案的不足。

代码中类图关系如下：  
![](https://github.com/niklai-star/images/blob/main/img1/hash_class_2.png)

Hashids的算法比较复杂，大致原理如下：

1. 内部维护了编码全集（默认0-9、大写字母、小写字母）
2. 通过配置的salt，以及一些算法对内置编码全集进行乱序，然后抽取出部分字符作为长度不够时的补足
3. 将数字按照剩下的字符全集的长度为进制进行转换得到编码
4. 如果编码长度不够，用抽取出的部分字符按照算法进行补足

从上面可以看出，其核心还是进制转换，这样保证了得到的编码不会有重复，同时又因为字符集经过了乱序，所以连续数字生成的编码没有规律。

#### Hash - MurmurHash

Hash算法可以将任意字符串进行hash后得到HashCode，因为题目限制最大长度为8，所以可以将HashCode进行62进制转换后得到编码。

任意多个字符串的HashCode之间是无规律的，所以转换的编码也是无规律的。但是Hash算法会产生碰撞，不同字符串的HashCode有可能相同，所以在当前代码中同时使用了以下两个方法：

1. 使用MurmurHash算法
2. 如果HashCode相同，则在url后面加上预置的后缀字符串后再次获取HashCode，直到不再相同为止。

> MurmurHash算法是一个优化的算法，有更低的碰撞率。但是仍然无法避免碰撞

代码中类图关系如下：  
![](https://github.com/niklai-star/images/blob/main/img1/hash_class_3.png)

代码中为了避免碰撞，维护了一个HashCode缓存，每次生成新的HashCode时查询以下缓存，如果存在就再次生成。

因为Hash算法不可避免的产生碰撞，所以不选此方案。

#### 关于短域名访问

浏览器输入短域名后，服务根据短域名查找到对应的长域名，以重定向的方式返回给浏览器。重定向分两种：

- 301：永久重定向。浏览器会缓存重定向之后的长域名，再次访问时将直接从缓存中获取，不再经过服务器。
- 302：临时重定向。每次访问短域名都会经过服务器，服务器将使浏览器重定向到长域名。

一般用户访问短域名时，服务器需要收集访问相关的信息，便于统计运维，所以使用302重定向。



###### 测试报告截图（项目根目录下有原图文件）
![](https://github.com/niklai-star/images/blob/main/img1/test-report.png)
