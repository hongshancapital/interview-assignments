#架构和设计:

##背景:
    需求:
        为长链接提供一个生产短连接的接口接口，并且绑定长链接和短连接的关系存储起来。当用户访问这个短连接的时候，可以自动访问到这个绑定关系的长链接的地址去。

    前置假设：
        我们拥有N（=90）个用于短链跳转的代理服务器和域名，例如：http://f01.cn/;http://f02.cn/;......,假设我们现在拥有90个这样的服务器，并且这90台服务器的处理能力是一致的。
        根据要求我们的绑定关系存储在JVM内存当中：考虑到内存溢出的情况，我们需要为这个存储设计一个容量。超过这个容量需要有一个淘汰机制，这里考虑使用LRU算法。
        根据上面的假设，需要考虑和解决如下3个问题：
 1. 生产的短链小均衡的落在这90台服务器上面，采用reHash算法让短链尽可能落在90台服务器上。达到[@相对均衡@]。
 2. 内存当中存储长短链的关系的容器使用ConcurrentLinkedHashMap（其实现了LRU算法），防止内存溢出。
 3. 实现长短链一对一的绑定关系，决定采用hash算法生成短链。即同一个长链接，生成的短链总是唯一的。

#上述2 的说明：
   JVM Xmx Xms 设定一般可在512~4096M 左右不等。根据实际情况可以不一样。我们一般的一个长链接：在0.3k左右。在短链的大小，一对链接（短链+长链）预估计在0.4k左右。
所以设计容量为：10000000（1千万）个长短链对，预计消耗4G左右的.
#框架选型及层次：
1. Spring Boot + MVC
2. 分层开发：Controller->Service->DataStorage+短链生成工具。