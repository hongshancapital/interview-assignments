## Design

> 需求分析

根据说明, 需设计两个接口, 并且接口中需要实现两种功能.

 	1. 接受一个长链接,返回一个短链接
 	2. 接受一个短链接,返回原始长链接

因此, 需实现一个算法, 能够将长链接转换成短链接, 并实现短链接还原会长链接, 实现短链接到长链接一一对应;

此次需求中, 明确要求短域名的长度为8个字符,且映射数据存储在jvm中,并防止内存溢出; 无DB层, 无文件层, 单机且不考虑扩展性, 由此, 衍生出三个子问题

	1. 如何保证内存不溢出
	2. 如何保证长短链接一一对应
	3. 如何保证发号不重复, 且发号效率足够

> 设计思路

1. 保证JVM内存不溢出的, 可采用LRU算法实现, 使内存中仅保存最近使用的短链接/长链接, 对超过一定时限的数据进行丢弃,

2. 保证长短链接一一对应, 使用放号器生成长链接->短链接的映射, 并采用两个LRU缓存, 一个存储长链接->短链接映射, 一个存储短链接-> 长链接映射, 相同长链接请求, 会命中缓存, 不会重复生成新的短链接地址;

3. 短链接的长度为8位, 采用62进制则可生成62^8 = 218340105584896, 约220万亿个地址, 对应十进制位数为15位, 对应2进制位数位48位, 且无需考虑扩展性, 因此可改造雪花算法,丢弃workerId段位,
   且开始时间戳位当年的时间戳进行缓存, (当前时间戳-当年初始时间戳)<<12|序列号 改造后的雪花算法, 具备当年不可重复性, 有序性, 以及理论最大每秒4096 * 1000 约400w的生成性能;

4. 对于缓存容量设计, 假设最大堆空间为8GB = 8 * 1024 * 1024 * 1024 => 8589934592 字节

   短链接为8位字符串=>32字节, 长链接平均长度位50字符=> 200字节, 长链接MD5位32位字符串=>128字节, 即 MD5(128): CODE(32); CODE(32):LongUrl(200) ,每个长短链接映射共占用
   400字节, 由此可知对于每个缓存容器最大容量约10000000个, 并设置超时时间为1个月, 此容量可保证JVM不会溢出

> 工程结构

````
``` 
org.example.shorturl.common
├── common     -- 统一返回及自定义业务异常
├── config         -- 系统配置
├── constatns    -- 系统常量
├── controller    -- 系统控制层
├── enums         -- 枚举常量
├── generator    -- id生成器
├── handler        -- 全局异常处理
├── modal          -- 模型对象
├── properties    -- 属性配置
├── service          -- 逻辑层
├── util          		-- 工具
```
````

> 系统逻辑

1. 长链接转短链接

<img src="https://s2.loli.net/2022/03/20/4ZSxCjfdN6QTcXA.png" alt="长链接转短链接调用链" style="zoom:50%;" />

2. 短链接转长连接

<img src="https://s2.loli.net/2022/03/20/vEHlAXcqRp9eQWz.png" alt="短链接转长链接调用链" style="zoom: 67%;" />

> 测试报告

1. 代码覆盖率

<img src="https://s2.loli.net/2022/03/20/Xof4V5sYuWrihLB.png" alt="代码覆盖率" style="zoom: 67%;" />

