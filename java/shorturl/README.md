****

## 项目背景

实现一个短域名服务，提供两个接口：

- 短域名存储接口：接受长域名信息，返回短域名信息
- 短域名读取接口：接受短域名信息，返回长域名信息。

短域名简介：短域名在很多地方都会用到，最常见的大概就是平时收到的各个平台发送的广告短信，比如这个：

![image-20211115193428818](img\image-20211115193428818.png)

其中的链接打开后的原链接为：

```
https://m.hellobike.com/ebike-h5/latest/index.html#/historyBill?queryCondition=c7cf5a218f1bf969f9b5ff57f5cac955664b7b9dc2593fcbc5f547d2bdaa8ddfd35e9d4f901589a501a6184b2473f469e18d31fa0e12488a354d324759dd25ef74d4cfb600512845ddb1a41e82046d52a8e67397c456b5e49215682607ea25211a6b3619fb8bb394
```

原来是一长串的带有参数的URL。那使用短链有啥好处呢？

- 某些平台对链接长度有限制，短链可以大大减少链接所占字符，比如微博和短信内容
- 有些时候要将链接转换为二维码的形式分享给别人，如果是长链的话二维码密集难识别，短链就不存在这个问题了

链接跳转的原理：访问短链后，请求返回了302重定向的状态码以及location值为对应长链的响应信息，然后浏览器就会再次请求这个长链完成最终的请求过程。

所以，如何设计一个服务来实现长链和短链的转换关系就是个比较重要的问题。



## 设计思路

本文采用的解决方案是，服务端设计一个发号器，需要存储的长域名都会分发一个独一无二的字符，然后存储ID字符与长域名之间的映射关系，并返回一个固定域名前缀+短域名字符组成的域名给用户，用户访问短域名时，根据后缀字符查询出对应的长链并返回即可。



整体的设计思路如下：

- 根据长域名生成短域名：

  ![image-20211116095923847](img\image-2021111134343.png)

- 根据短域名返回对应长域名：

![image-20211116095923847](img\image-20211116095923847.png)

一些细节考虑：

#### 如何实现一个发号器

发号器其实就是一个生成唯一ID的算法，这种算法有很多，比如：

- UUID：全局唯一，但是ID比较长，无序，插入db时可能会频繁导致页分裂，影响插入性能
- 数据库自增：有上限，高并发下读写压力大
- Redis自增ID：性能好，但是需要考虑持久化、高可用等，成本有点高
- 雪花算法：全局唯一，有序，但是依赖系统时钟的一致性。

考虑到性能以及成本，这里我们采用雪花算法来实现发号器生成唯一ID。

#### 雪花算法生成的ID字符太多，怎样压缩字符

雪花算法生成的ID为long类型，效果如下：

```
1460429721253842944
1460429721253842945
```

可以看到本身的长度比较长，好像和我们所需要的短域名还有一定差距，但是这个好解决，把这个long数值转换为62进制就可以了，上面这两个ID转换为62进制后的字符如下：

```
1JSMAdXJWik
1JSMAdXJWil
```

看起来效果很接近了，再在前面拼上一个固定的域名，就完美了，比如这样：

```
http://www.sdsd.com/1JSMAdXJWik
```



#### 怎样存储长短域名映射关系

存储的话也有很多方案，比如数据库、缓存、磁盘文件等，当然也可以组合起来使用，比如设计表用来存储长短域名映射关系，然后利用缓存来增加查询的性能。

缓存的话也有两种，一种是JVM自身缓存，类似于代码里面创建的Arralist、HashMap这种，另一种是专门用来存储数据的缓存服务器，例如redis。

这里为了方便，直接采用JVM缓存来存储，由于涉及到映射关系，因此采用Map数据结构来保存。

当然，如果说自己手动来实现一个Map缓存的话，还需要考虑设置超时时间、LRU内存淘汰机制等一系列问题，因此这里采用Guava Cache来实现，它是一个Google出品的专门用于实现本地缓存的框架，比自己写的绝对靠谱。

#### 相同的长域名存储应该如何处理

正常情况下，相同的长域名生成的短域名应该是一样的，但是由于是通过发号器来处理的，就没法保证相同长域名映射到同一个短域名上。如果需要保证这个的话，得进行额外的处理：

- 根据长域名去存储库里面搜索，如果有匹配的，就直接返回对应的短域名。优点是：省空间，缺点是根据长域名去查询性能差。
- 额外建一个空间用于存储长域名和短域名映射关系，既能通过短域名查找对应的长域名，也能通过短域名查找对应的长域名。优点是根据长域名查询性能高，缺点是需要额外的存储空间。



## 成果展示

启动后访问：http://localhost:8080/swagger-ui.html，可以看到和测试swagger生成的接口文档。

jacoco代码覆盖率报告：

![image-20211116144131724](img\image-20211116144131724.png)

代码整体覆盖率：97%，分支覆盖率：86%。



## 可以优化的点



#### IP黑名单接口防盗刷处理

为了防止黑客攻击生成大量的短链接，或者不断查询不存在的域名导致占用大量的服务器资源，有必要进行IP访问限制，这种功能一般是基础资源，会放到网关层进行拦截处理，和应用服务实现解耦。

#### 数据存储结构优化

目前在存储长域名之前会先去缓存中判断长域名是否存在，是直接进行遍历判断，这种数据量大的情况下性能很差，因此解决办法可以在存储映射关系的时候，既保存短域名和长域名映射关系，也保存长域名和短域名的映射关系，这样查询起来就会比较快，但是不好的点在于会需要额外一倍的存储空间。

