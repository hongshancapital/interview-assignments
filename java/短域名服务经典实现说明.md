## 短链接服务设计文档

## 1、解体思路

### 短域名的生成

根据长链接的请求通过**雪花算法**给其分配一个随机的不重复且保证顺序的uuid，进行62进制转换，定为8位短域名；

选型思考：基于发号策略去生成短链接，同一个长链接每次生成的短链接是不一样的，基于对业务的考虑，个人认为这对于用户体验影响不大，另外有个好处就是不需要去解决hash冲突的一些问题。

### 存储

**键值对存储Map选型**——**ConcurrentHashMap**

以“短域名-长域名”键值对的方式，保存在Map中，基于线程安全的考虑，一般会选择ConcurrentHashMap、SkipListMap, TrieMap的实现，从效率的角度来说，hashMap的读写效率都是最优的，这里使用**ConcurrentHashMap**作为短链接映射关系的存储（当然这几种Map想要全部支持的话可使用策略+工厂+模板模式进行设计），然而由于其内部的Node数组有长度不可超过Int最大值的限制，导致其可支持的容量不可大于2^30。不过在实际使用中，最大容量也受到物理内存的限制，本地测试（16G物理内存，8G空闲），经压测不抛出OOM的安全容量在2^26左右。

**布隆过滤器**

在进行长短链进行请求的时，将生成短链接打到**布隆过滤器中，**作为后期将不存在的短链请求过滤掉；



### 过期策略

为减少内存的使用，我设计了**ExpireMap**的结构，可定期清理长期键值对。在每次get短链接url时，将过期时间设置为**当前时间+ttl间隔**（默认设置30d）。同时后台启动一个**定期任务**去检查那些键值对，清除当前时间>过期时间的。



## 2、接口说明



### 根据长域名生成短域名



url: POST   /getShortUrl
步骤: 首先进行URL的一些处理（中文转码，包括没有协议的加上协议等），然后基于雪花算法生成唯一uuid然后再进行62进行转换存储在map本地内存中。

### 根据短域名跳转长域名



url: GET /{shorgetLongUrl}

步骤: 从map本地内存查找键值对，更新过期时间。

## 3、测试

### 3.1 性能测试

map对2^20（百万+）做put, get性能测试

```plain
StopWatch 'map写性能测试': running time = 165832125 ns
---------------------------------------------
ns         %     Task name
---------------------------------------------
165832125  100%  hashMap: put测试

get.prettyPrint()~~~~~~~~~~~~~~~~~
StopWatch 'map读性能测试': running time = 42477375 ns
---------------------------------------------
ns         %     Task name
---------------------------------------------
042477375  100%  hashMap: get测试
```

### 3.2 单元测试结果

Jacoco单元测试用例执行结果如下：其中分支覆盖率**96%**，行覆盖率接近**95%**。

![img](https://cdn.nlark.com/yuque/0/2022/png/3018486/1642560268351-b177b395-9c5a-47e7-922b-913bd53a23fa.png)

##  

### 

## 





## 