# 短域名服务技术方案设计

## 0x01 目标
撰写两个 API 接口
1. 短域名存储接口：接受长域名信息，返回短域名信息
2. 短域名读取接口：接受短域名信息，返回长域名信息。

限制
1. 短域名长度最大为 8 个字符（不含域名）

提交内容需包括
1. 源代码
2. 单元测试代码以及单元测试覆盖率
3. API 集成测试案例以及测试结果
4. 简单的框架设计图，以及所有做的假设
5. 涉及的 SQL 或者 NoSQL 的 Schema，注意标注出 Primary key 和 Index 如果有。

## 0x02 方案及选型
### 2.1、接口设计
#### 2.2.2、短域名存储接口
地址: POST /shorturl/create

参数:
| Name | Type   | Required | Description |
| ---- | ------ | -------- | ----------- |
| url  | String | true     | 原始地址    |

返回：
| Name    | Type   | Example | Description |
| ------- | ------ | ------- | ----------- |
| shortId | String | 1dSS6Nl | 短链接id    |

#### 2.2.3、短域名读取接口
地址: GET /longurl/get/:id
参数:
| Name | Type   | Required | Description |
| ---- | ------ | -------- | ----------- |
| id   | String | true     | 短链接id    |

返回：
| Name | Type   | Example               | Description |
| ---- | ------ | --------------------- | ----------- |
| url  | String | https://www.baidu.com | 原始地址    |

### 2.2、ID生成策略
短链接ID生成策略业界有两种，一种是自增id，一种是md5。自增id的优点在于不会重复，缺点在于长度不定，百度短网址用的是这种算法；md5的优点在
于长度固定，缺点在于有出现碰撞的可能，微博用的是这种算法。以上两种算法都有大厂在实践中使用，以下重点阐述一下两种算法的细节，看哪种更适合本次题目的要求。

#### 2.2.1、ObjectId
天生不重复，复杂度最小，但是长度较长，转成62进制后为16位数。若对URL长度没有硬性要求，可以用这种方案。

#### 2.2.2、自增ID
自增ID的实现方案
1. 用mongo的$inc做取号器。
2. 将第一步得到的10进制数转为62进制。
3. 从916132832开始，以保证对应的62进制起始位数是6位。
4. 对62进制的base进行乱序，即不按[0-9a-zA-Z]来，以确保ID看上去不像数字，避免有人产生遍历的想法。

6位62进制的上限是56800235583，即使有一天超过了这个数字也不怕，因为存储的ID变长了一位而已，并没有其他什么副作用。

#### 2.2.3、md5算法
md5算法稍微复杂一点，好处是可以生成固定长度的ID，且无法遍历；坏处是存在碰撞风险。当然，对于碰撞风险，也是有办法解决的，我下面详细描述一种可能的md5方案。
1. 将原始url、log信息、salt（默认为0）组成一个大json，将该json进行stringify，然后md5，得到32位的16进制数字。
2. 将第一步得到的32位16进制数字转成62进制（10个数字+26个小写字母+26个大写字母），取前6位。
3. 用后六位在数据库中检索，若不存在则存储，若存在则检验原始url和log。若原始url和log相同，则认为是同一个配置，直接返回该ID。若不同，则认为发生了碰撞，salt+1后重复1-3的运算。重试过程内部完成，不对业务方暴露。重复三次依然失败，则向用户返回失败信息，由程序员介入排查。

该方案的好处除了长度固定外，还有就是它的ID是有意义的。ID是打点配置的指纹，通过检索ID，即可知道该打点配置是否已存在，防止一份打点配置对应多个ID。但是为了保证该唯一性，每次生成新纪录时，都要对整个数据库进行检索，看该ID是否存在。当数据量大了之后，这个消耗是十分惊人的。

#### 2.2.3、结论
最终确定以稳健性和唯一性为主，放弃对url长度的坚持，故最终采用自增Id的方案，符合本题要求链接长度不多于8。

### 2.3、缓存策略
这里本来考虑的是加两层缓存，一层redis，一层nodejs嵌入式缓存。本次没有采用redis，而直接采用嵌入式缓存的原因如下：
1. mongodb对读取的处理有自己的缓存机制，在读取处理上和redis差不多，加一层redis并不能起到什么作用，且会增加代码复杂度以及redis服务器的支出；
2. 直接用nodejs的嵌入式缓存（使用LRU算法），不用redis，这样的好处在于出现压力时，可以方便地水平扩展，只要加node节点即可，不需要升mongo配置；

> 最终采用的缓存策略为：mongo + nodejs嵌入式缓存

## 0x03 项目运行

```bash
# 发开模式
npm run dev
```

```bash
# 项目构建
npm run build
```

```bash
# 应用测试
npm run coverage
```

