# 短连接服务设计

场景生成url调用少，取回url调用多。很适合使用缓存。

有三种哈希方式：第一种是对url本身进行md5或者sha1之类的哈希方式，好处是反查询的时候方便，有一定概率冲突但是比较少，问题是无法满足8位长度的要求。第二种是通过自增id去做一个转换隐藏数据库id，好处是长度可控并且不会有冲突，坏处是通过已存在的url查hash的时候比较麻烦。第三种是随机hash，好处是方便固定长度但是冲突概率比较大，坏处跟第二种一样反查比较麻烦，分布式场景下生成的id有可能冲突。

这里选择第二种方案，哈希库使用hashids，数据库使用mysql。项目要求8位长度可以基本可以覆盖int类型的自增id长度。因为可以解码所以不用再hash上增加索引，查hash->url时直接用主键进行查找。

url里切分出域名，path。

path存储使用varchar，长度8182。限制来自于chrome默认的最大url长度。nginx 默认的header长度限制也在4k或者8k。

domain字段长度300，限制来自于dns 253域名长度。包括协议，域名，端口号。

domain_crc32，path_crc32 长度32，一起作为联合索引反查url。对path与domain进行crc32哈希，然后建立索引加快查询效率。

使用redis的布隆过滤器验证url或者hash是否在系统里存在。可以有效阻止缓存穿透。

做url->hash查询时先过布隆过滤器查url是否存在，存在时去数据库查hash，切分域名与path，然后优先使用索引进行查找，如果没找到走生成数据。不存在时新生成一条数据使用新的自增id生成hash。有并发生成场景需要在redis做一个互斥锁。

做hash->url查询时先过布隆过滤器查hash是否存在，存在时去缓存取hash->url，缓存没有时做一个互斥锁去数据库取数据，如果没取到返回空字符串。不存在时返回空字符串。

缓存使用redis，去重与预防缓存穿透需要使用布隆过滤器，优先考虑使用redisbloom模块。

配置文件 salt ，数据库连接，缓存连接，服务器域名

黑名单域名表，过滤一些不合规域名的短连接请求，启动时载入缓存，查不到时查一遍数据库

ip白名单与简单token做鉴权

收集接口调用信息做后续数据挖掘

依赖 epxress hashids sequelize redis-modules-sdk-ts

