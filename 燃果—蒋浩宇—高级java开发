package com.superman.test;

import io.swagger.annotations.Api;
import io.swagger.annotations.ApiImplicitParam;
import io.swagger.annotations.ApiImplicitParams;
import io.swagger.annotations.ApiOperation;

import java.util.Hashtable;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import javax.servlet.http.HttpServletRequest;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import com.alibaba.druid.support.logging.Log;
import com.alibaba.druid.support.logging.LogFactory;
import com.superman.global.core.ctr.ChineEnterpriseInfo;

/**
 * 短域名 采用
 * 
 * @author jianghaoyu
 *
 */
@Api(description = "短域名读写模块")
@RestController
public class SuperService {
	
	//记录日志
	private final static Log log = LogFactory.getLog(SuperService.class);

	/**
	 * 配置一个线程池
	 * 本机器是 cpu4核，8g内存 这里设置线程最大量，4个并发翻2倍
	 * 
	 */
	private static ExecutorService executorService = Executors.newFixedThreadPool(8);
	
	//实现第一次实例化服务于对象
	private StorageServer storageServer = new StorageServer();
	
	/**
	 * 短域名存储接口 <br>
	 * test: https://localhost:9091/acceptLDI?value=长域名信息 <br>
	 * 
	 * @param value
	 *            接受长域名信息
	 * 
	 * @return
	 * 
	 */
	@ApiOperation(value = "短域名存储接口", notes = "短域名存储接口")
	@ApiImplicitParams({ @ApiImplicitParam(name = "value", value = "接受长域名信息", required = true, paramType = "query", dataType = "String") })
	@RequestMapping(value = "/storageService", method = RequestMethod.POST, produces = { "application/json;charset=UTF-8;" })
	@ResponseBody
	public String storageService(HttpServletRequest req) {
		String value = req.getParameter("value") == null ? "" : req.getParameter("value");
		if (value.equals("")) {
			return "{\"state\":\"fail\",\"info\":\"非法请求缺少参数\",\"data\":\"\"}";
		}
		log.info("storage:" + value+" info");
		Future<String> feature = executorService.submit(new Callable<String>() {
			@Override
			public String call() throws Exception {
				String key = storageServer.storageServiceImpl(value);
				return key;
			}
		});
		if(feature.isDone()){
			log.info("程序运行中");
		}
		String key="";
		try {
			key = feature.get();
			log.info("storage:" + value+" info return key:"+key);
		} catch (InterruptedException e) {
			log.error("storage:" + value+" info error:"+e.toString());
		} catch (ExecutionException e) {
			log.error("storage:" + value+" info error:"+e.toString());
		}
		return key;
	}

	/**
	 * 短域名读取接口 <br>
	 *  
	 * @param key 接受长域名信息 查询key
	 * 
	 * @return 
	 * 
	 */
	@ApiOperation(value = "短域名读取接口", notes = "短域名读取接口")
	@ApiImplicitParams({ @ApiImplicitParam(name = "key", value = "接受短域名信息", required = true, paramType = "query", dataType = "String") })
	@RequestMapping(value = "/readService", method = RequestMethod.POST, produces = { "application/json;charset=UTF-8;" })
	@ResponseBody
	public String readService(HttpServletRequest req) {
		String key = req.getParameter("key") == null ? "" : req.getParameter("key");
		if (key.equals("")) {
			return "{\"state\":\"fail\",\"info\":\"非法请求缺少参数\",\"data\":\"\"}";
		}
		log.info("query:" + key+" info");
		Future<String> feature = executorService.submit(new Callable<String>() {
			@Override
			public String call() throws Exception {
				String value = storageServer.storageServiceImpl(key);
				return value;
			}
		});
		if(feature.isDone()){
			log.info("程序运行中");
		}
		String value="";
		try {
			value = feature.get();
		} catch (InterruptedException e) {
			e.printStackTrace();
		} catch (ExecutionException e) {
			e.printStackTrace();
		}
		return value;
	}

}

/**
 * 存储并发服务器<br>
 * 采用读写锁实现，读读共享，写写相斥
 * 
 * @author jianghaoyu
 *
 */
class StorageServer {
	
	//记录日志
	private final static Log log = LogFactory.getLog(StorageServer.class);

	//采用读写锁
	private final static ReadWriteLock lock = new ReentrantReadWriteLock();

	// 短域名数据存放
	private static Map<String, String> domainNameData = new Hashtable<String, String>();

	// 存储数据
	public String storageServiceImpl(String value) {
		lock.writeLock().lock();
		try {
			// 自动生成key
			String key = System.currentTimeMillis() + "";
			domainNameData.put(key, value);
			return "{\"state\":\"success\",\"info\":\"" + key + "\",\"code\":\"200\"}";
		} catch (Exception e) {
			log.error(e.toString());
			return "{\"state\":\"error\",\"info\":\"非法请求\",\"code\":\"500\"}";
		} finally {
			lock.writeLock().unlock();
		}
	}

	// 读取数据
	public String readServiceImpl(String key) {
		lock.readLock().lock();
		try {
			// 自动生成key
			String value = domainNameData.get(key);
			return "{\"state\":\"success\",\"info\":\"" + value + "\",\"code\":\"200\"}";
		} catch (Exception e) {
			log.error(e.toString());
			return "{\"state\":\"error\",\"info\":\"非法请求,或无数据\",\"code\":\"500\"}";
		} finally {
			lock.readLock().unlock();
		}
	}
}




